<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.129.0"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ycchi0 Blog</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://ycchi0.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ycchi0.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ycchi0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ycchi0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ycchi0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ycchi0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://ycchi0.github.io/index.xml">
<link rel="alternate" hreflang="en" href="https://ycchi0.github.io/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Ycchi0 Blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ycchi0.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ycchi0 Blog"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Ycchi0 Blog",
  "url": "https://ycchi0.github.io/",
  "description": "",
  "thumbnailUrl": "https://ycchi0.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ycchi0.github.io/" accesskey="h" title="Ycchi0 Blog (Alt + H)">Ycchi0 Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">003.Go基础 代替枚举的方法
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言没有直接提供枚举（enum）关键字或专门的枚举类型。不过，Go 使用常量（const）和类型别名结合其他特性，提供了一种有效的枚举替代方式。这种方式既保持了 Go 语言的简洁性，也能够达到枚举的功能。
1. 使用 const 和 iota Go 中常见的枚举替代方法是使用 const 和 iota。iota 是一个特殊的标识符，它在 const 块中自动递增，常用于定义一系列相关常量。
示例：简单的枚举 package main import &#34;fmt&#34; const ( Red = iota // 0 Green // 1 Blue // 2 ) func main() { fmt.Println(Red, Green, Blue) // 输出：0 1 2 } iota 从 0 开始，每声明一个常量，它的值会自动递增。因此，在上面的例子中，Red、Green 和 Blue 分别对应 0、1 和 2。 2. 定义类型别名来增强枚举的类型安全性 为了增强类型安全性并使枚举更具可读性，通常会为这些常量定义一个自定义的类型别名。这样可以限制变量只能取该类型中的值，类似于传统编程语言中的枚举类型。
示例：带类型的枚举 package main import &#34;fmt&#34; // 定义一个自定义类型 type Color int // 使用 iota 定义枚举值 const ( Red Color = iota Green Blue ) func main() { var c Color = Green fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:52:05 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 003.Go基础 代替枚举的方法" href="https://ycchi0.github.io/posts/003.go%E5%9F%BA%E7%A1%80-%E4%BB%A3%E6%9B%BF%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">002.Go基础 基础数据类型
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言是一种静态强类型语言，提供了多种基础数据类型，主要分为 布尔型、数字型、字符串型 和 特殊类型（byte 和 rune），此外还有一些常用的复合类型。以下是详细介绍：
1. 布尔型（Boolean） 类型： bool 取值： true 或 false 示例： var isTrue bool = true var isFalse bool = false 2. 数字类型（Numeric Types） 数字类型分为 整数类型、浮点数类型 和 复数类型。
2.1. 整数类型（Integer Types） 有符号整数： 类型： int8, int16, int32, int64 范围： int8: -128 到 127 int16: -32,768 到 32,767 int32: -2,147,483,648 到 2,147,483,647 int64: -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 示例： var a int8 = -100 var b int32 = 10000 无符号整数： 类型： uint8, uint16, uint32, uint64 范围： uint8: 0 到 255 uint16: 0 到 65,535 uint32: 0 到 4,294,967,295 uint64: 0 到 18,446,744,073,709,551,615 示例： var c uint8 = 200 var d uint32 = 40000 机器字长整数： 类型： int, uint 范围： 取决于系统架构（32 位或 64 位）。 示例： var e int = -50 var f uint = 50 2....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:51:43 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 002.Go基础 基础数据类型" href="https://ycchi0.github.io/posts/002.go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">001.Go基础 变量与常量
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，变量和常量是两种不同的存储和管理数据的方式。
它们有各自的特点和用途。我们来分别讨论：
1. 变量（Variables） 声明和使用： 变量是可以改变值的存储单元。你可以在程序运行过程中多次赋值修改它的值。 Go 语言通过关键字 var 声明变量。也可以使用简短的 := 语法来声明和初始化变量。 var x int = 10 // 声明变量并赋初始值 y := 20 // 使用简短声明，类型推断为 int 特点： 类型系统：Go 是静态类型语言，变量声明时可以指定类型。如果不指定类型，编译器会根据初始化的值推断类型。 默认值：如果声明变量时没有赋值，Go 会赋予该变量一个“零值”。例如，整数类型的零值是 0，布尔类型的零值是 false。 var z int // z 的值为 0，默认值 可变性：变量的值是可以更改的。例如，你可以多次对一个变量进行赋值： x = 15 // 重新赋值 多变量声明： Go 支持同时声明多个变量：
var a, b, c int = 1, 2, 3 2. 常量（Constants） 声明和使用： 常量是程序运行期间不可改变的值。它们在定义时必须赋值，并且赋值后不能再修改。 常量通过 const 关键字声明。 const Pi float64 = 3....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:49:46 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 001.Go基础 变量与常量" href="https://ycchi0.github.io/posts/001.go%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ETCD应用场景
    </h2>
  </header>
  <div class="entry-content">
    <p>前置知识 ETCD的租约机制 租约是ETCD中的一种抽象，它可以关联到一个或多个键值对，当租约过期时，与其关联的所有键值对都会被自动删除。
以下是ETCD租约机制的主要特性和使用方式：
创建租约：客户端可以通过调用ETCD的API创建一个新的租约。创建租约时需要指定一个TTL（Time To Live），表示租约的有效期。创建成功后，ETCD会返回一个唯一的租约ID。
关联键值对：客户端在创建或修改键值对时，可以指定一个租约ID，将键值对关联到这个租约。这样，当租约过期时，这个键值对会被自动删除。
续租：客户端可以通过调用ETCD的API来续租一个租约，即重新设置租约的TTL。这样可以防止租约过期，与其关联的键值对被删除。
撤销租约：客户端可以通过调用ETCD的API来撤销一个租约。撤销租约会导致与其关联的所有键值对被立即删除。
租约超时：如果客户端在租约的TTL时间内没有进行续租操作，那么租约会自动过期，与其关联的所有键值对都会被ETCD自动删除。
一个租约可以挂多个key，一个key只能挂一个租约
应用场景 服务发现 服务注册与发现(Service Discovery)是ETCD最常见的使用场景，解决的是如何在同一个分布式集群中的进程或服务找到目标服务的IP地址并建立连接。
在分布式系统中，服务提供者都是以集群的方式对外提供服务，集群中服务的IP随时都可能发生变化，因此服务提供者需要将自己的服务注册到ETCD中去。这样，服务使用者通过ETCD可以获取到实际服务提供者的ip信息，连接到服务提供者，进行后续操作。
消息发布与订阅 使用ETCD进行消息发布与订阅，实际上就是构建一个配置共享中心
消息发布方在将消息存储到对应的key上，消息订阅者在ETCD节点上注册一个Watcher并等待，以后每次配置有更新的适合，ETCD都会实时通知订阅者，以此达到获取最新配置信息的目的。
分布式锁 ETCD实现分布式锁的关键在于其Compare-and-Swap（CAS）操作和TTL（Time To Live）特性。
以下是ETCD实现分布式锁的详细步骤：
获取锁：客户端尝试获取锁，通过调用ETCD的CAS操作。在这个操作中，客户端会尝试创建一个键值对，键是锁的名称，值是一个唯一标识（例如，客户端的ID或者UUID）。同时，这个键值对会设置一个TTL，表示锁的过期时间。如果这个键值对创建成功，那么就表示客户端成功获取到了锁。如果键值对创建失败（通常是因为键已经存在，即锁已经被其他客户端持有），那么客户端就没有获取到锁。
持有锁：一旦客户端获取到锁，就可以执行需要同步的操作。在这个过程中，其他客户端无法获取到锁，也就无法执行相同的操作。
释放锁：客户端在完成需要同步的操作后，需要释放锁，让其他客户端有机会获取锁。释放锁是通过调用ETCD的Delete操作，删除对应的键值对来实现的。
锁的过期：如果客户端在持有锁的过程中崩溃，可能无法正常释放锁。这时，ETCD的TTL特性就会发挥作用。ETCD会在键值对的TTL时间到达后，自动删除这个键值对，从而释放锁。这样可以防止因为客户端崩溃导致的锁无法释放，阻塞其他客户端的问题。
等待锁：如果客户端尝试获取锁失败（即锁已经被其他客户端持有），那么客户端可以选择等待锁被释放。这通常是通过轮询的方式实现的，客户端会定期尝试获取锁，直到成功为止。
通过这种方式，ETCD可以在分布式环境下实现锁的同步，保证在同一时刻，只有一个客户端能够执行需要同步的操作。这对于保证分布式系统的数据一致性非常重要。</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 17:37:32 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to ETCD应用场景" href="https://ycchi0.github.io/posts/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">跨域问题处理方案
    </h2>
  </header>
  <div class="entry-content">
    <p>使用 Nginx 反向代理处理跨域问题 在 Nginx 配置文件中设置一个代理服务器，并添加一些额外的头信息。
location /api/ { add_header &#39;Access-Control-Allow-Origin&#39; &#39;*&#39;; add_header &#39;Access-Control-Allow-Methods&#39; &#39;GET, POST, OPTIONS&#39;; add_header &#39;Access-Control-Allow-Headers&#39; &#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&#39;; add_header &#39;Access-Control-Expose-Headers&#39; &#39;Content-Length,Content-Range&#39;; proxy_pass http://target.com; } 然后重启 Nginx 以应用这些更改：
在 Vue.js 项目中处理跨域问题 在vue.config.js文件中，配置 devServer.proxy 选项来设置代理规则。例如：
module.exports = { devServer: { host: &#34;127.0.0.1&#34;, port: 8084, open: true, proxy: { &#34;/api&#34;: { // &#39;/api&#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的 target: &#34;http://xxx.xxx.xx.xx:8080&#34;, //目标地址，一般是指后台服务器地址 changeOrigin: true, //是否跨域 pathRewrite: { // pathRewrite 的作用是把实际Request Url中的&#39;/api&#39;用&#34;&#34;代替 &#34;^/api&#34;: &#34;&#34;, }, }, }, }, }; 保存并重启 Vue 开发服务器，新的代理设置应该就生效了。 注意：这种方法只在开发环境中有效，因为它依赖于 Vue CLI 的开发服务器。在生产环境中，你可能需要在你的后端服务器上设置 CORS 或使用其他方法来处理跨域问题。</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 16:27:47 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 跨域问题处理方案" href="https://ycchi0.github.io/posts/%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Redis 缓存设计
    </h2>
  </header>
  <div class="entry-content">
    <p>典型 Web 应用缓存设计架构 在一个典型的 Web 应用中，从前端请求到 Nginx 再到后端服务的多级缓存设计可以如下：
浏览器缓存：这是最接近用户的一级缓存。浏览器会根据 HTTP 的缓存控制头字段（如 Expires、Cache-Control、Last-Modified、ETag 等）来决定是否需要向服务器发送请求，还是直接从本地缓存中获取资源。
CDN 缓存：内容分发网络（CDN）是一种常见的缓存策略，它可以将内容缓存到离用户最近的节点，从而减少网络延迟。当用户的请求到达 CDN 节点时，如果节点中有缓存的内容，就直接返回给用户；如果没有，就向源服务器请求内容，并将内容缓存到节点中。
Nginx 缓存：Nginx 是一种常见的反向代理服务器，它可以将后端服务器的响应缓存起来，从而减少对后端服务器的请求。当用户的请求到达 Nginx 时，如果 Nginx 中有缓存的响应，就直接返回给用户；如果没有，就向后端服务器请求内容，并将响应缓存起来。
应用服务器本地缓存：应用服务器可以使用本地内存作为缓存，存储经常访问的数据。这样，对于相同的请求，应用服务器可以直接从本地缓存中获取数据，而不需要访问数据库或者分布式缓存。这种缓存的优点是访问速度快，但是缺点是无法在多个应用服务器之间共享数据。
分布式缓存：当数据不在应用服务器的本地缓存中时，应用服务器可以从分布式缓存（如 Redis 或 Memcached）中获取数据。分布式缓存可以在多个应用服务器之间共享数据，但是访问速度相对于本地缓存会慢一些。
数据库缓存：数据库也有自己的缓存机制，例如 MySQL 的查询缓存。当收到相同的查询请求时，数据库可以直接从缓存中返回结果，而不需要再次执行查询。
在这个过程中，每一级缓存都可以减少对下一级的访问，从而提高系统的性能。
但是，也需要注意缓存的更新和失效问题，以保证数据的一致性。
缓存设计 在设计缓存系统时，我们需要考虑以下几个问题：
缓存穿透 缓存穿透是指用户查询的数据既不在缓存中，也不在数据库中，这样的查询请求就会“穿透”缓存层，直接请求数据库。这种情况通常发生在用户查询一些不存在的数据时。
例如，假设我们有一个商品信息的系统，用户可以通过商品 ID 查询商品信息。
当用户查询一个不存在的商品 ID 时，系统首先会在缓存中查找，如果没有找到，就会去数据库中查找。但是因为这个商品 ID 不存在，所以数据库中也找不到。这样，每次查询这个商品 ID，都会直接访问数据库，而不会利用到缓存。
如果有大量这样的查询请求，就会给数据库带来很大的压力，可能导致数据库崩溃。这就是缓存穿透。
为了防止缓存穿透，常见的解决方案有：
过滤非法请求：在应用层增加校验，对于用户的输入进行校验，过滤掉不存在的查询。
使用布隆过滤器：布隆过滤器是一种数据结构，它可以用来判断一个元素是否在一个集合中。我们可以将所有可能存在的数据哈希到布隆过滤器中，当用户查询数据时，先在布隆过滤器中查找，如果布隆过滤器判断数据不存在，就直接返回，不再查询缓存和数据库。
缓存空对象：即使数据库中没有数据，也将“空”结果进行缓存，但是这种缓存的有效期通常设置得比较短。
缓存击穿 缓存击穿是指当某个热点数据的缓存过期失效的瞬间，大量的请求同时涌入，这些请求都会穿透缓存直接请求数据库，可能会导致数据库瞬间压力过大。
举个例子，假设一个电商网站的某个热销商品信息被大量用户频繁查询，这个商品信息在缓存中有对应的缓存项。
然而，当这个缓存项到达过期时间，还没有来得及被更新，此时又有大量的请求涌入查询这个商品信息，这些请求会直接打到数据库上，可能会导致数据库压力过大，甚至崩溃，这就是缓存击穿。
为了防止缓存击穿，常见的解决方案有：
设置热点数据永不过期：对于一些访问非常频繁的热点数据，可以设置其在缓存中永不过期，或者在程序中控制在缓存失效后立即重新加载。
使用互斥锁：当缓存失效的时候，不是立即去加载数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcached 的 ADD），当操作返回成功时，再去加载数据库，否则，就重试获取缓存。这样可以保证对于一个 key，数据库只会被加载一次。
使用缓存预热策略：缓存预热就是系统上线后，将可能被用户访问的数据主动加载到缓存中，这样用户在访问数据时，就已经在缓存中了。可以通过定时任务，在非高峰时间对可能的热点数据进行预热，加载到缓存中。
设置不同的过期时间：为了避免大量的缓存同时过期，可以为每个缓存设置不同的过期时间，比如在一个基础过期时间上加上一个随机值。
缓存雪崩 缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层。...</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 09:55:49 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to Redis 缓存设计" href="https://ycchi0.github.io/posts/redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Redis的单线程和高性能
    </h2>
  </header>
  <div class="entry-content">
    <p>Redis是单线程吗？ Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。
但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其 实是由额外的线程执行的。
Redis 单线程如何处理那么多的并发客户端连接？ Redis的IO多路复用：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。
Redis 单线程为什么还能这么快？ 因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。
正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。
Redis 遍历 keys 用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用。
在需要遍历的场景下，需要使用 scan 命令进行渐进式遍历
SCAN cursor [MATCH pattern] [COUNT count] scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式，第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历 到返回的 cursor 值为 0 时结束。
注意：但是scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说scan并不能保证完整的遍历出来所有的键， 这些是我们在开发时需要考虑的。</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 09:12:51 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to Redis的单线程和高性能" href="https://ycchi0.github.io/posts/redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Redis核心数据结构及应用场景
    </h2>
  </header>
  <div class="entry-content">
    <p>五种核心数据结构及其应用场景 String 最基本的类型，一个 key 对应一个 value，value 其实不仅可以是 String，也可以是数字。常规 key-value 缓存应用。
应用场景
缓存： 如果我们有一个用户信息，用户 ID 为 123，用户信息为&#34;John&#34;，我们可以这样存储：
SET user:123 &#34;John&#34; 当我们需要获取这个用户的信息时，我们可以这样获取：
GET user:123 计数器：
如果我们需要对一个网页的访问次数进行计数，我们可以这样操作：
INCR page_view:1 每当有新的访问时，我们就执行上面的命令，这样就可以实时统计网页的访问次数。
分布式锁：
如果我们需要对一个资源进行加锁，我们可以这样操作：
SET lock:resource_name &#34;lock_value&#34; NX EX 30 这个命令会尝试设置一个键，如果这个键不存在，那么设置成功，我们就获取到了锁，如果这个键已经存在，那么设置失败，我们就没有获取到锁。EX 参数表示这个键的过期时间，这样可以防止死锁。
会话缓存：
如果我们需要存储一个用户的会话信息，我们可以这样操作：
SET session:123 &#34;session_info&#34; 当我们需要获取这个用户的会话信息时，我们可以这样获取：
GET session:123 页面缓存：
如果我们需要缓存一个网页的内容，我们可以这样操作：
SET page:1 &#34;page_content&#34; 当我们需要获取这个网页的内容时，我们可以这样获取：
GET page:1 分布式系统全局序列号
redis 批量生成序列号提升性能
INCRBY orderId 1000 Hash 用于存储对象，即多个字段及字段值，通过 key 和字段名（field）来唯一确定一个值。适合用于存储对象。
应用场景
存储对象：哈希表是存储对象的理想选择。例如，如果你有一个用户对象，你可以使用用户的 ID 作为键，用户的其他信息（如姓名、电子邮件等）作为值。
示例：
HSET user:1000 name &#34;John Doe&#34; HSET user:1000 email &#34;john....</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 08:00:45 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to Redis核心数据结构及应用场景" href="https://ycchi0.github.io/posts/redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">Explain详解与索引最佳实践
    </h2>
  </header>
  <div class="entry-content">
    <p>Explain Explain是MySQL中的一个非常有用的工具，它可以帮助我们理解MySQL是如何执行SQL查询的。
通过使用Explain，我们可以看到查询的执行计划，包括使用了哪些索引，表的连接顺序，预计要扫描的行数等信息。
这些信息可以帮助我们优化查询，提高查询效率。
EXPLAIN SELECT * FROM users WHERE id = 1; Explain的结果包含以下几个重要的列：
id 查询的标识符，如果一个查询包含多个子查询，那么每个子查询都会有一个不同的id。
select_type 表示对应行是简单还是复杂的查询。
simple：简单查询。查询不包含子查询和union primary：复杂查询中最外层的 select subquery：包含在 select 中的子查询（不在 from 子句中） derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） CREATE TABLE customers ( id INT PRIMARY KEY, name VARCHAR(50) ); CREATE TABLE orders ( id INT PRIMARY KEY, customer_id INT, amount DECIMAL(10, 2) ); INSERT INTO customers (id, name) VALUES (1, &#39;John&#39;), (2, &#39;Jane&#39;), (3, &#39;Bob&#39;); INSERT INTO orders (id, customer_id, amount) VALUES (1, 1, 100....</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 06:44:34 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to Explain详解与索引最佳实践" href="https://ycchi0.github.io/posts/explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">深入理解MySQL索引底层数据结构
    </h2>
  </header>
  <div class="entry-content">
    <p>索引是什么 索引是帮助MySQL高效获取数据的排好序的数据结构。
InnoDB 索引实现 InnoDB 存储引擎使用一种称为 B&#43;Tree 的数据结构来实现其索引。B&#43;Tree 是 B-Tree 的一种变体，它在数据库索引中的应用非常广泛。
B&#43;树是一种自平衡的树，可以保持数据有序。这种数据结构可以大大加快数据的检索速度，尤其是在处理大量数据时。
在B&#43;树中，所有的数据都存储在叶子节点，而非叶子节点只存储关键字和子节点的指针。
同时，叶子节点之间通过指针相连，这样可以提高范围查询的效率。MySQL 对b&#43; 树做了优化,叶子节点之间是双向连接，标准的 b&#43; 树是从左指向右,单向连接
此外，MySQL还支持哈希索引，但是哈希索引只能满足&#34;=&#34;,“IN” 和&#34;&lt;=&gt;“查询，不能使用范围查询和排序，所以B&#43;树是MySQL的主要索引结构。
InnoDB 存储引擎有两种类型的索引：主键索引（聚簇索引）和二级索引（非聚簇索引）。
主键索引 InnoDB 的数据是按照主键顺序存放的，也就是说主键索引的叶子节点就是数据节点。因此，按照主键查询可以直接通过索引找到数据，效率非常高。
二级索引 二级索引的叶子节点并不包含行记录的全部数据。相反，它的叶子节点包含的是对应行数据的主键值。当通过二级索引查找时，InnoDB 会先找到二级索引指向的主键，然后再通过主键索引找到完整的行数据。这就是所谓的“回表”。
MyISAM 的索引 MyISAM索引文件和数据文件是分离的。在MyISAM存储引擎中，每个表被存储为三个文件。一个是表定义文件（.frm），一个是数据文件（.MYD），还有一个是索引文件（.MYI）。
数据文件和索引文件是分离的，这也是MyISAM的一个特点。 数据文件存储了表的数据，而索引文件则存储了表的索引信息。这种分离的设计使得MyISAM在处理大量数据时具有一定的优势，因为索引和数据可以分别进行IO操作，提高了数据处理的效率。
但是，这种设计也有一些缺点。例如，如果在操作过程中发生故障，可能会导致数据文件和索引文件之间的不一致，从而影响数据的完整性。此外，MyISAM不支持事务，这也是其在某些场景下被InnoDB等其他存储引擎所取代的原因。
为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？ InnoDB 存储引擎在存储数据时，会按照主键的顺序进行存储。
如果没有主键，InnoDB 会选择一个唯一非空索引代替，如果这样的索引也没有，InnoDB 会生成一个隐藏的聚簇索引。
这个隐藏的聚簇索引会占用额外的存储空间，而且由于它不是由用户定义的，所以在执行查询时可能会导致性能下降。
使用整型的自增主键有以下几个优点：
整型的自增主键可以保证数据的插入顺序，这样可以避免页面分裂，提高插入效率 整型的自增主键占用的空间小，可以减少索引的存储空间，提高查询效率。 自增主键可以避免主键的重复，保证数据的唯一性。 使用自增主键，可以避免在插入数据时需要手动指定主键值，简化了插入操作 为什么非主键索引结构叶子节点存储的是主键值？ 简单来说就是为了一致性和节省存储空间。
在InnoDB存储引擎中，非主键索引（也称为二级索引）的叶子节点存储的是主键值，这是由InnoDB的存储结构决定的。
InnoDB使用聚簇索引（也就是主键索引）来存储数据，这意味着表中的数据实际上是按照主键的顺序存储的。因此，主键值实际上就是数据行在物理存储上的地址。
当我们通过非主键索引进行查询时，InnoDB首先会在非主键索引中查找到主键值，然后再通过主键值在聚簇索引中查找到实际的数据行。这个过程通常被称为“回表”。
这样设计的好处是，非主键索引可以更小，因为它只需要存储主键值，而不需要存储整行数据。这可以节省存储空间，提高IO效率。同时，由于所有的非主键索引都引用了主键，所以在更新数据时，只需要更新聚簇索引，而不需要更新每一个非主键索引，这也可以提高更新操作的效率。
但是，这也意味着如果频繁地进行非主键索引查询，可能会导致大量的“回表”操作，从而影响查询性能。因此，在设计数据库时，需要根据实际的查询需求来合理选择使用主键索引还是非主键索引。
索引最左前缀原理 最左前缀原理，也被称为最左前缀匹配原则，是指在多列索引中，查询可以只使用索引的最左边的一部分，但必须是连续的部分。这是因为多列索引是按照列的顺序，从左到右进行排序的。
例如，如果我们有一个包含三列（A，B，C）的索引，那么以下查询可以使用索引： 查询只涉及到 A 列。 查询涉及到 A 和 B 列。 查询涉及到 A，B 和 C 列。
但是，如果查询只涉及到 B 列或者 C 列，或者涉及到 A 和 C 列（跳过了 B 列），那么索引将不会被使用。这就是最左前缀原理。...</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 05:27:40 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 深入理解MySQL索引底层数据结构" href="https://ycchi0.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://ycchi0.github.io/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://ycchi0.github.io/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://ycchi0.github.io/">Ycchi0 Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
