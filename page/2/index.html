<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.129.0"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ycchi0 Blog</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://ycchi0.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ycchi0.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ycchi0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ycchi0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ycchi0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ycchi0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://ycchi0.github.io/index.xml">
<link rel="alternate" hreflang="en" href="https://ycchi0.github.io/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Ycchi0 Blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ycchi0.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ycchi0 Blog"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Ycchi0 Blog",
  "url": "https://ycchi0.github.io/",
  "description": "",
  "thumbnailUrl": "https://ycchi0.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ycchi0.github.io/" accesskey="h" title="Ycchi0 Blog (Alt + H)">Ycchi0 Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">009.Go基础 指针
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，指针是指向变量内存地址的变量。指针可以用来直接操作内存，并且可以通过指针共享数据，避免不必要的拷贝。在 Go 中，虽然没有像 C 语言那样的指针运算，但 Go 提供了简单且安全的指针功能，使开发者可以在安全的环境下进行内存操作。
1. 指针的基本概念 指针是保存内存地址的变量。通过指针，我们可以间接地访问或修改变量的值。
示例：指针的基本使用 var x int = 42 var p *int = &amp;x // 获取变量x的地址，并将其赋值给指针p fmt.Println(p) // 输出内存地址，例如：0xc0000140b0 fmt.Println(*p) // 输出指针p指向的值，即42 在这个例子中：
&amp;x 是取变量x的地址，返回一个指向x的指针。 *p 是解引用操作，通过指针p访问其指向的变量的值。 2. 指针类型 Go 语言中的每种类型都有其对应的指针类型。例如：
int类型的指针是*int float64类型的指针是*float64 自定义类型的指针也是类似的。 示例：不同类型的指针 var a int = 10 var b float64 = 25.5 var c string = &#34;hello&#34; var pA *int = &amp;a var pB *float64 = &amp;b var pC *string = &amp;c fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:54:55 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 009.Go基础 指针" href="https://ycchi0.github.io/posts/009.go%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">008.Go基础 函数
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，函数是程序的基本构建块之一。函数定义了可复用的代码块，通过传递参数和返回值来实现逻辑封装。Go 语言的函数具有灵活和强大的特性，如支持多返回值、匿名函数、闭包以及延迟执行（defer）等。接下来，我将介绍 Go 语言中的函数特性及其使用方式。
1. 基本函数定义 Go 语言中，函数的定义使用关键字func，并且参数和返回值的类型必须显式声明。
func 函数名(参数列表) 返回值类型 { // 函数体 } 示例：基本函数 func add(x int, y int) int { return x &#43; y } func main() { result := add(3, 4) fmt.Println(result) // 输出 7 } 在这个示例中，add函数接受两个int类型的参数，并返回它们的和。
2. 多返回值函数 Go 语言允许函数返回多个值。这在需要返回结果和错误状态的情况下特别有用。
示例：多返回值 func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(&#34;hello&#34;, &#34;world&#34;) fmt.Println(a, b) // 输出 world hello } 在这个示例中，swap函数返回两个字符串，通过多重赋值操作接收返回值。...</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:54:38 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 008.Go基础 函数" href="https://ycchi0.github.io/posts/008.go%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">007.Go基础 Chan
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，chan（通道）是一种用于在多个 Goroutine 之间传递数据的机制。Go 语言通过 Goroutines 实现并发，而通道（Channel）是这些 Goroutines 之间进行通信的工具。通道可以发送和接收数据，帮助程序在并发场景下保持数据的一致性和同步性。
通道的定义与基本用法 通道在 Go 中是一个类型化的管道，声明时需要指定通道传输的数据类型。你可以创建一个传输不同类型数据的通道，比如传输整数、字符串或结构体。
1. 通道的声明和初始化 使用make函数来创建通道：
ch := make(chan int) // 创建一个传输int类型数据的通道 2. 发送和接收数据 发送数据到通道：使用&lt;-符号将数据发送到通道。 从通道接收数据：使用&lt;-符号从通道接收数据。 ch := make(chan int) // 向通道发送数据 go func() { ch &lt;- 42 }() // 从通道接收数据 value := &lt;-ch fmt.Println(value) // 输出 42 在上面的示例中，go func()是一个 Goroutine，运行在一个独立的线程中。它将42发送到通道ch中，主 Goroutine 则从通道中接收该值并打印。
通道的同步特性 通道不仅仅用于传递数据，它还可以作为一种同步机制。当一个 Goroutine 尝试向通道发送数据时，除非另一个 Goroutine 正在从该通道接收数据，否则它会被阻塞。同样，接收操作会阻塞，直到有数据从通道发送过来。因此，通道可以用来确保多个 Goroutine 之间的操作同步。
示例：同步两个 Goroutine ch := make(chan bool) go func() { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:54:16 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 007.Go基础 Chan" href="https://ycchi0.github.io/posts/007.go%E5%9F%BA%E7%A1%80-chan/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">006.Go基础 循环语句
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，循环语句主要通过for关键字实现。Go 语言不像其他一些编程语言（如 C、Java）有while和do-while循环，for是唯一的循环结构，但它非常灵活，可以实现多种类型的循环。以下是 Go 语言中几种常见的循环用法：
1. 标准的for循环 这种for循环和 C 语言、Java 中的for循环类似，包含三个部分：初始化语句、条件表达式和后置语句。
for i := 0; i &lt; 10; i&#43;&#43; { fmt.Println(i) } 初始化语句：在循环开始时执行一次（i := 0）。 条件表达式：每次循环前都会判断，条件为true时继续执行循环（i &lt; 10）。 后置语句：每次循环结束后执行（i&#43;&#43;）。 2. 类似while的循环 如果省略初始化语句和后置语句，for循环可以用来模拟while循环：
i := 0 for i &lt; 10 { fmt.Println(i) i&#43;&#43; } 这种形式的for循环类似于其他语言中的while循环，在条件为true时持续执行。
3. 无限循环 如果for的条件表达式也被省略，那么就变成了一个无限循环：
for { fmt.Println(&#34;无限循环&#34;) } 这种循环通常与break或return配合使用，用于在特定条件下退出循环。
4. range 关键字遍历集合 Go 语言的for循环还可以结合range关键字用于遍历数组、切片、映射和字符串：
// 遍历数组 arr := []int{1, 2, 3, 4} for index, value := range arr { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:53:56 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 006.Go基础 循环语句" href="https://ycchi0.github.io/posts/006.go%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">005.Go基础 分支语句
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言中的分支结构用于根据条件执行不同的代码路径。常见的分支结构有 if 语句、switch 语句和特殊的 select 语句。每种分支结构都有其适用场景，下面我将详细介绍它们。
1. if 语句 if 语句是最常用的条件分支结构，依据一个布尔表达式的结果来决定是否执行某段代码。Go 语言的 if 语句语法简单，且支持可选的初始化语句。
语法： if condition { // 当 condition 为 true 时执行 } 示例：基本 if 语句 package main import &#34;fmt&#34; func main() { x := 10 if x &gt; 5 { fmt.Println(&#34;x 大于 5&#34;) } } 示例：带初始化语句的 if Go 语言的 if 语句支持在条件判断前执行一个短语句，这个特性通常用于声明和初始化局部变量。
if x := 10; x &gt; 5 { fmt.Println(&#34;x 大于 5&#34;) } x 只在 if 语句的作用域内可见。 if-else 语句 if condition { // 当 condition 为 true 时执行 } else { // 当 condition 为 false 时执行 } 示例：if-else 语句 x := 3 if x &gt; 5 { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:53:27 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 005.Go基础 分支语句" href="https://ycchi0.github.io/posts/005.go%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">004.GO基础 运算符
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言的运算符主要分为以下几大类：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。每类运算符都用于特定的操作，帮助程序完成各种计算和逻辑判断。下面是详细介绍：
1. 算术运算符（Arithmetic Operators） 算术运算符用于执行基本的数学运算。
运算符 描述 示例 结果 &#43; 加法 5 &#43; 3 8 - 减法 5 - 3 2 * 乘法 5 * 3 15 / 除法 5 / 2 2（整除） % 取余 5 % 2 1 &#43;&#43; 自增 a&#43;&#43; 等同于 a = a &#43; 1 -- 自减 a-- 等同于 a = a - 1 注意：
&#43;&#43; 和 -- 是 后缀运算符，即先返回当前值，再自增或自减。 整数除法会丢弃小数部分，例如 5 / 2 的结果为 2，而不是 2....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:52:59 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 004.GO基础 运算符" href="https://ycchi0.github.io/posts/004.go%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">003.Go基础 代替枚举的方法
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言没有直接提供枚举（enum）关键字或专门的枚举类型。不过，Go 使用常量（const）和类型别名结合其他特性，提供了一种有效的枚举替代方式。这种方式既保持了 Go 语言的简洁性，也能够达到枚举的功能。
1. 使用 const 和 iota Go 中常见的枚举替代方法是使用 const 和 iota。iota 是一个特殊的标识符，它在 const 块中自动递增，常用于定义一系列相关常量。
示例：简单的枚举 package main import &#34;fmt&#34; const ( Red = iota // 0 Green // 1 Blue // 2 ) func main() { fmt.Println(Red, Green, Blue) // 输出：0 1 2 } iota 从 0 开始，每声明一个常量，它的值会自动递增。因此，在上面的例子中，Red、Green 和 Blue 分别对应 0、1 和 2。 2. 定义类型别名来增强枚举的类型安全性 为了增强类型安全性并使枚举更具可读性，通常会为这些常量定义一个自定义的类型别名。这样可以限制变量只能取该类型中的值，类似于传统编程语言中的枚举类型。
示例：带类型的枚举 package main import &#34;fmt&#34; // 定义一个自定义类型 type Color int // 使用 iota 定义枚举值 const ( Red Color = iota Green Blue ) func main() { var c Color = Green fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:52:05 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 003.Go基础 代替枚举的方法" href="https://ycchi0.github.io/posts/003.go%E5%9F%BA%E7%A1%80-%E4%BB%A3%E6%9B%BF%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">002.Go基础 基础数据类型
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言是一种静态强类型语言，提供了多种基础数据类型，主要分为 布尔型、数字型、字符串型 和 特殊类型（byte 和 rune），此外还有一些常用的复合类型。以下是详细介绍：
1. 布尔型（Boolean） 类型： bool 取值： true 或 false 示例： var isTrue bool = true var isFalse bool = false 2. 数字类型（Numeric Types） 数字类型分为 整数类型、浮点数类型 和 复数类型。
2.1. 整数类型（Integer Types） 有符号整数： 类型： int8, int16, int32, int64 范围： int8: -128 到 127 int16: -32,768 到 32,767 int32: -2,147,483,648 到 2,147,483,647 int64: -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 示例： var a int8 = -100 var b int32 = 10000 无符号整数： 类型： uint8, uint16, uint32, uint64 范围： uint8: 0 到 255 uint16: 0 到 65,535 uint32: 0 到 4,294,967,295 uint64: 0 到 18,446,744,073,709,551,615 示例： var c uint8 = 200 var d uint32 = 40000 机器字长整数： 类型： int, uint 范围： 取决于系统架构（32 位或 64 位）。 示例： var e int = -50 var f uint = 50 2....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:51:43 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 002.Go基础 基础数据类型" href="https://ycchi0.github.io/posts/002.go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">001.Go基础 变量与常量
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，变量和常量是两种不同的存储和管理数据的方式。
它们有各自的特点和用途。我们来分别讨论：
1. 变量（Variables） 声明和使用： 变量是可以改变值的存储单元。你可以在程序运行过程中多次赋值修改它的值。 Go 语言通过关键字 var 声明变量。也可以使用简短的 := 语法来声明和初始化变量。 var x int = 10 // 声明变量并赋初始值 y := 20 // 使用简短声明，类型推断为 int 特点： 类型系统：Go 是静态类型语言，变量声明时可以指定类型。如果不指定类型，编译器会根据初始化的值推断类型。 默认值：如果声明变量时没有赋值，Go 会赋予该变量一个“零值”。例如，整数类型的零值是 0，布尔类型的零值是 false。 var z int // z 的值为 0，默认值 可变性：变量的值是可以更改的。例如，你可以多次对一个变量进行赋值： x = 15 // 重新赋值 多变量声明： Go 支持同时声明多个变量：
var a, b, c int = 1, 2, 3 2. 常量（Constants） 声明和使用： 常量是程序运行期间不可改变的值。它们在定义时必须赋值，并且赋值后不能再修改。 常量通过 const 关键字声明。 const Pi float64 = 3....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:49:46 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 001.Go基础 变量与常量" href="https://ycchi0.github.io/posts/001.go%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">ETCD应用场景
    </h2>
  </header>
  <div class="entry-content">
    <p>前置知识 ETCD的租约机制 租约是ETCD中的一种抽象，它可以关联到一个或多个键值对，当租约过期时，与其关联的所有键值对都会被自动删除。
以下是ETCD租约机制的主要特性和使用方式：
创建租约：客户端可以通过调用ETCD的API创建一个新的租约。创建租约时需要指定一个TTL（Time To Live），表示租约的有效期。创建成功后，ETCD会返回一个唯一的租约ID。
关联键值对：客户端在创建或修改键值对时，可以指定一个租约ID，将键值对关联到这个租约。这样，当租约过期时，这个键值对会被自动删除。
续租：客户端可以通过调用ETCD的API来续租一个租约，即重新设置租约的TTL。这样可以防止租约过期，与其关联的键值对被删除。
撤销租约：客户端可以通过调用ETCD的API来撤销一个租约。撤销租约会导致与其关联的所有键值对被立即删除。
租约超时：如果客户端在租约的TTL时间内没有进行续租操作，那么租约会自动过期，与其关联的所有键值对都会被ETCD自动删除。
一个租约可以挂多个key，一个key只能挂一个租约
应用场景 服务发现 服务注册与发现(Service Discovery)是ETCD最常见的使用场景，解决的是如何在同一个分布式集群中的进程或服务找到目标服务的IP地址并建立连接。
在分布式系统中，服务提供者都是以集群的方式对外提供服务，集群中服务的IP随时都可能发生变化，因此服务提供者需要将自己的服务注册到ETCD中去。这样，服务使用者通过ETCD可以获取到实际服务提供者的ip信息，连接到服务提供者，进行后续操作。
消息发布与订阅 使用ETCD进行消息发布与订阅，实际上就是构建一个配置共享中心
消息发布方在将消息存储到对应的key上，消息订阅者在ETCD节点上注册一个Watcher并等待，以后每次配置有更新的适合，ETCD都会实时通知订阅者，以此达到获取最新配置信息的目的。
分布式锁 ETCD实现分布式锁的关键在于其Compare-and-Swap（CAS）操作和TTL（Time To Live）特性。
以下是ETCD实现分布式锁的详细步骤：
获取锁：客户端尝试获取锁，通过调用ETCD的CAS操作。在这个操作中，客户端会尝试创建一个键值对，键是锁的名称，值是一个唯一标识（例如，客户端的ID或者UUID）。同时，这个键值对会设置一个TTL，表示锁的过期时间。如果这个键值对创建成功，那么就表示客户端成功获取到了锁。如果键值对创建失败（通常是因为键已经存在，即锁已经被其他客户端持有），那么客户端就没有获取到锁。
持有锁：一旦客户端获取到锁，就可以执行需要同步的操作。在这个过程中，其他客户端无法获取到锁，也就无法执行相同的操作。
释放锁：客户端在完成需要同步的操作后，需要释放锁，让其他客户端有机会获取锁。释放锁是通过调用ETCD的Delete操作，删除对应的键值对来实现的。
锁的过期：如果客户端在持有锁的过程中崩溃，可能无法正常释放锁。这时，ETCD的TTL特性就会发挥作用。ETCD会在键值对的TTL时间到达后，自动删除这个键值对，从而释放锁。这样可以防止因为客户端崩溃导致的锁无法释放，阻塞其他客户端的问题。
等待锁：如果客户端尝试获取锁失败（即锁已经被其他客户端持有），那么客户端可以选择等待锁被释放。这通常是通过轮询的方式实现的，客户端会定期尝试获取锁，直到成功为止。
通过这种方式，ETCD可以在分布式环境下实现锁的同步，保证在同一时刻，只有一个客户端能够执行需要同步的操作。这对于保证分布式系统的数据一致性非常重要。</p>
  </div>
  <footer class="entry-footer"><span title='2024-05-30 17:37:32 +0000 UTC'>May 30, 2024</span></footer>
  <a class="entry-link" aria-label="post link to ETCD应用场景" href="https://ycchi0.github.io/posts/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="prev" href="https://ycchi0.github.io/">
      «&nbsp;Prev&nbsp;
    </a>
    <a class="next" href="https://ycchi0.github.io/page/3/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://ycchi0.github.io/">Ycchi0 Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
