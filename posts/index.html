<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Posts | Ycchi0 Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Posts - Ycchi0 Blog">
<meta name="author" content="">
<link rel="canonical" href="https://ycchi0.github.io/posts/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ycchi0.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ycchi0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ycchi0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ycchi0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ycchi0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://ycchi0.github.io/posts/index.xml">
<link rel="alternate" hreflang="en" href="https://ycchi0.github.io/posts/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Posts" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ycchi0.github.io/posts/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Posts"/>
<meta name="twitter:description" content=""/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ycchi0.github.io/posts/"
    }
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ycchi0.github.io/" accesskey="h" title="Ycchi0 Blog (Alt + H)">Ycchi0 Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 
<header class="page-header">
  <h1>
    Posts
  </h1>
</header>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">020.Go入门-并发编程
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言中的并发是其核心功能之一，它通过轻量级的 goroutine 和强大的通信机制（通道，channels）来支持高效的并发编程。Go 以简洁和高效的方式处理并发，而不是像传统语言那样依赖操作系统级线程。Go 的并发模型受到 CSP（Communicating Sequential Processes）模型的启发，注重通过消息传递来实现不同线程之间的协作。
1. Goroutines（协程） Goroutine 是 Go 语言的并发执行单元。它类似于线程，但比线程更轻量。Go 的运行时会自动调度 goroutine，而不是依赖操作系统线程调度。一个 Go 程序可以同时运行成千上万个 goroutine，这得益于它的低开销。
语法：只需要在函数调用前加上 go 关键字即可启动一个新的 goroutine。
示例：
package main import ( &#34;fmt&#34; &#34;time&#34; ) func say(s string) { for i := 0; i &lt; 5; i&#43;&#43; { fmt.Println(s) time.Sleep(100 * time.Millisecond) } } func main() { go say(&#34;Hello&#34;) // 启动一个新的 goroutine say(&#34;World&#34;) // 在主 goroutine 中运行 } 在这个例子中，say(&#34;Hello&#34;) 和 say(&#34;World&#34;) 运行在不同的 goroutine 中。这展示了 Go 的并发特性。...</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-18 02:42:03 +0000 UTC'>October 18, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 020.Go入门-并发编程" href="https://ycchi0.github.io/posts/020.go%E5%85%A5%E9%97%A8-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">019.Go入门-错误处理
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，错误处理是通过显式返回错误值来实现的，而不是依赖像其他语言（如 Java、Python）中的异常机制。这种设计强调了错误处理的明确性和简洁性，使开发者在编写代码时可以更清晰地处理可能发生的错误。
1. Go 中的错误处理机制 Go 使用内置的 error 类型来表示错误。error 是一个接口，定义如下：
type error interface { Error() string } 任何实现了 Error() 方法的类型都可以作为错误类型。通常，Go 的函数会返回两个值：一个是正常的返回值，另一个是表示错误的 error。如果没有错误发生，error 通常会返回 nil。
示例：
package main import ( &#34;errors&#34; &#34;fmt&#34; ) // 定义一个简单的函数，返回一个错误 func divide(a, b int) (int, error) { if b == 0 { return 0, errors.New(&#34;cannot divide by zero&#34;) } return a / b, nil } func main() { result, err := divide(4, 2) if err !...</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-18 02:32:30 +0000 UTC'>October 18, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 019.Go入门-错误处理" href="https://ycchi0.github.io/posts/019.go%E5%85%A5%E9%97%A8-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">017.Go入门-nil
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，nil 是一个特殊的标识符，用来表示变量没有值或空值。nil 类似于其他编程语言中的 null 或 None，但它在 Go 中具有特定的应用场景。nil 可以用于多个类型，包括指针、接口、切片、映射、通道、函数等。
1. nil 的用途 Go 语言中的 nil 可用于以下几种类型：
指针：表示指针不指向任何内存地址。 接口：表示接口的动态类型和值为空。 切片：表示切片不引用底层数组。 映射：表示映射未被初始化。 通道：表示通道未被初始化。 函数：表示函数变量未被赋值。 2. nil 的使用场景 2.1 指针与 nil 在 Go 中，指针是一种保存变量内存地址的类型，nil 可以表示指针不指向任何有效的内存地址。
示例：
package main import &#34;fmt&#34; func main() { var p *int = nil // 定义一个 nil 指针 fmt.Println(p) // 输出：&lt;nil&gt; var x int = 10 p = &amp;x // 将 p 指向变量 x fmt.Println(p) // 输出：x 的地址 fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-18 01:37:32 +0000 UTC'>October 18, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 017.Go入门-nil" href="https://ycchi0.github.io/posts/017.go%E5%85%A5%E9%97%A8-nil/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">016.Go入门-类型的内嵌
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言中的**类型内嵌（Type Embedding）是实现代码复用和简化类型设计的重要特性之一，它允许一个结构体或接口将另一个类型嵌入到自身中，而不需要通过显式继承来实现。内嵌类似于面向对象语言中的“继承”机制，但更灵活和简洁。通过类型内嵌，Go 实现了组合（Composition）**这一设计模式，提供了高效的代码复用方式。
1. 结构体的内嵌 结构体可以直接嵌入另一个结构体，从而使得嵌入的类型的字段和方法可以直接在外层结构体中使用，而不需要显式引用嵌入的类型。这类似于传统的“继承”，但更加简化。
结构体内嵌示例：
package main import &#34;fmt&#34; // 定义一个基础结构体 type Animal struct { Name string } // 为 Animal 结构体定义方法 func (a Animal) Speak() { fmt.Println(a.Name, &#34;makes a sound&#34;) } // 定义一个新结构体，将 Animal 内嵌 type Dog struct { Animal // 内嵌 Animal 结构体 Breed string } func main() { d := Dog{ Animal: Animal{Name: &#34;Rex&#34;}, // 初始化内嵌的 Animal 类型 Breed: &#34;Labrador&#34;, } // 直接访问内嵌的 Animal 结构体的字段和方法 fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-18 01:35:38 +0000 UTC'>October 18, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 016.Go入门-类型的内嵌" href="https://ycchi0.github.io/posts/016.go%E5%85%A5%E9%97%A8-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%B5%8C/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">015.Go入门-面向对象
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言虽然不完全符合传统的面向对象编程（OOP）模型，但它具有一些关键的 OOP 特性，例如封装、组合和多态，这些可以通过 Go 的**结构体（struct）和接口（interface）**来实现。
在 Go 语言中，面向对象的概念不是通过继承和类来实现，而是通过组合与接口设计来模拟和实现多态性和扩展性。
1. Go 语言的结构（struct） Go 中的结构体（struct）类似于其他语言中的类，但没有继承关系。struct 是一种聚合数据类型，用于将多个字段组织在一起。与类不同的是，Go 没有构造函数或析构函数的概念，也没有隐式的继承。
定义结构体：
type Person struct { Name string Age int } 使用结构体：
func main() { p := Person{Name: &#34;Alice&#34;, Age: 25} fmt.Println(p.Name) // 输出：Alice fmt.Println(p.Age) // 输出：25 } 为结构体定义方法 Go 中的方法是绑定到类型（包括结构体）的。方法的接收者可以是值类型或指针类型，这取决于你想在方法中修改结构体还是只读取它的内容。
type Person struct { Name string Age int } // 为结构体定义方法 func (p Person) Greet() { fmt.Println(&#34;Hello, my name is&#34;, p.Name) } func main() { p := Person{Name: &#34;Alice&#34;, Age: 25} p....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-18 01:20:40 +0000 UTC'>October 18, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 015.Go入门-面向对象" href="https://ycchi0.github.io/posts/015.go%E5%85%A5%E9%97%A8-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">014.Go入门-扩展类型
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，拓展已有类型的方式主要有两种：创建类型别名和定义新类型。通过这两种方式，你可以为已有类型添加新的行为或定义，尤其是在不想修改原有类型的情况下。下面分别解释这两种方式。
1. 类型别名（Type Alias） 类型别名用于为现有类型创建一个新的名称。这实际上不会创建新的类型，只是为原有类型提供了一个新的名字。
语法：
type NewType = ExistingType 示例：
package main import ( &#34;fmt&#34; ) type MyInt = int // MyInt 是 int 的别名 func main() { var a MyInt = 100 fmt.Println(a) // 输出：100 } 特点：
别名类型和原始类型完全相同，可以相互赋值。 别名主要用于代码重构或增加代码可读性。 2. 定义新类型（Type Declaration） 通过定义新类型，你可以基于已有类型创建一个新的类型，并为这个新类型添加方法。新类型和原始类型在 Go 中被视为不同的类型，即使它们底层的表示相同。
语法：
type NewType ExistingType 示例：
package main import ( &#34;fmt&#34; ) type MyInt int // 基于 int 定义了新类型 MyInt // 为 MyInt 类型定义一个方法 func (m MyInt) Print() { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-18 01:15:07 +0000 UTC'>October 18, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 014.Go入门-扩展类型" href="https://ycchi0.github.io/posts/014.go%E5%85%A5%E9%97%A8-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">013.Go入门 Range
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，range 是一个用于遍历各种数据结构的关键字，包括数组、切片、字符串、map 和通道。它提供了一种简洁、通用的方式来访问集合中的元素。
1. range 用于数组和切片 当 range 用于 数组 或 切片 时，它返回两个值：索引 和 元素的副本。
示例：range 遍历数组或切片 arr := []int{10, 20, 30, 40} for i, v := range arr { fmt.Printf(&#34;索引: %d, 值: %d\n&#34;, i, v) } 输出：
索引: 0, 值: 10 索引: 1, 值: 20 索引: 2, 值: 30 索引: 3, 值: 40 i 是索引 v 是该索引处元素的副本 只需要元素或索引时 如果只需要索引或值，可以使用 下划线_ 忽略不需要的值。
只需要索引： for i := range arr { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:56:40 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 013.Go入门 Range" href="https://ycchi0.github.io/posts/013.go%E5%85%A5%E9%97%A8-range/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">012.Go基础 Map
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，map是一种内置的数据结构，用于存储键值对（key-value pairs）。它非常类似于其他编程语言中的哈希表（hash table）或字典（dictionary）。Go 语言中的map提供了高效的键值查找、插入和删除操作，是处理关联数据的首选结构。
1. map 的定义和初始化 map的定义方式为map[keyType]valueType，其中keyType表示键的类型，valueType表示值的类型。
示例：定义一个map var m map[string]int // 声明一个key为string，value为int的map 在 Go 中，map的零值是nil，如果没有进行初始化就直接操作map，会导致运行时错误。因此，使用map之前必须先进行初始化。
1.1 使用 make 初始化 map Go 提供了内置的make函数来初始化map。
m := make(map[string]int) // 使用make函数创建一个map m[&#34;apple&#34;] = 5 m[&#34;banana&#34;] = 10 fmt.Println(m) // 输出 map[apple:5 banana:10] 在这个例子中，我们使用make函数初始化了一个map，并通过键值对的方式插入了两个元素。
1.2 使用字面量创建和初始化 map 除了使用make函数，map还可以通过字面量直接创建并初始化。
m := map[string]int{ &#34;apple&#34;: 5, &#34;banana&#34;: 10, } fmt.Println(m) // 输出 map[apple:5 banana:10] 这种方式不仅简洁，而且可以在声明时同时进行赋值。
2. map 的基本操作 2.1 插入元素 在map中插入元素的方式非常简单，直接通过map[key] = value的形式即可。
m := make(map[string]int) m[&#34;orange&#34;] = 20 // 插入键&#34;orange&#34;对应的值为20 2....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:56:21 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 012.Go基础 Map" href="https://ycchi0.github.io/posts/012.go%E5%9F%BA%E7%A1%80-map/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">011.Go基础 切片
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，切片（slice） 是一种非常重要的数据结构，它是对数组的抽象，是一个动态大小的序列。与数组不同，切片的长度是可以变化的，因而更灵活、更常用。切片本质上是对底层数组的引用，允许我们在不复制数据的情况下处理数组的某一部分。
1. 切片的定义与创建 切片由三部分组成：指针（指向底层数组的某个元素）、长度（当前切片中包含的元素数）和容量（从切片的起始位置到底层数组末尾的元素数）。
创建切片的方式有几种常见的方式： 1.1 使用现有数组创建切片 通过数组生成切片，可以通过array[start:end]的方式从数组中创建切片，切片不包含end位置的元素。
arr := [5]int{1, 2, 3, 4, 5} slice := arr[1:4] // 从数组创建切片，包含索引1到索引3的元素 fmt.Println(slice) // 输出 [2 3 4] 1.2 使用make()函数创建切片 make函数是 Go 语言中用于创建切片、映射（map）和通道（channel）的内置函数。通过make函数创建切片时，可以指定切片的长度和容量。
slice := make([]int, 3, 5) // 创建长度为3，容量为5的切片 fmt.Println(slice) // 输出 [0 0 0] 在这个例子中，切片slice的长度是3，容量是5，所有元素初始化为0。
1.3 使用切片字面量创建切片 可以像数组一样使用字面量创建切片。不同的是，切片不需要指定长度，长度由初始值的个数决定。
slice := []int{1, 2, 3, 4} fmt.Println(slice) // 输出 [1 2 3 4] 2. 切片的长度和容量 长度：切片中的元素个数，通过len()函数可以获取切片的长度。 容量：切片从起始位置到底层数组末尾的元素数，通过cap()函数可以获取切片的容量。 示例：查看切片的长度和容量 slice := []int{1, 2, 3, 4, 5} fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:55:56 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 011.Go基础 切片" href="https://ycchi0.github.io/posts/011.go%E5%9F%BA%E7%A1%80-%E5%88%87%E7%89%87/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">010.Go基础 数组
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，数组是一种固定长度、同构（同一类型）的数据集合。数组可以存储同一类型的数据元素，并且数组的长度在声明时就被确定，不能动态改变。Go 语言的数组有明确的类型和长度，因此与一些动态语言中的数组不同，Go 的数组在使用时需要考虑其长度和类型。
1. 数组的定义 在 Go 语言中，数组通过方括号[]定义，方括号中的数字表示数组的长度，之后跟随数组中元素的类型。数组的长度是数组类型的一部分，因此长度不同的数组是不同的类型。
示例：数组的定义和初始化 var arr [5]int // 声明一个长度为5的int类型数组，元素默认值为0 fmt.Println(arr) // 输出 [0 0 0 0 0] 在这个例子中，声明了一个int类型的数组arr，它有 5 个元素，每个元素的初始值为0（因为 Go 中的整数类型默认值是0）。
2. 数组的初始化 数组在声明的同时可以进行初始化。可以使用字面量的方式为数组赋值，或者只初始化部分元素，剩下的元素会使用该类型的零值进行填充。
示例：数组的初始化 arr1 := [5]int{1, 2, 3, 4, 5} // 初始化一个长度为5的数组 fmt.Println(arr1) // 输出 [1 2 3 4 5] arr2 := [5]int{1, 2} // 部分初始化，剩余元素自动赋值为0 fmt.Println(arr2) // 输出 [1 2 0 0 0] 可以通过这种方式只初始化数组的一部分，未初始化的元素会自动设为该类型的默认值。
3. 使用自动推断长度的数组 在数组初始化时，可以省略数组的长度，Go 会根据提供的初始值个数自动推断数组的长度。
示例：自动推断数组长度 arr := [....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:55:16 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 010.Go基础 数组" href="https://ycchi0.github.io/posts/010.go%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://ycchi0.github.io/posts/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://ycchi0.github.io/">Ycchi0 Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
