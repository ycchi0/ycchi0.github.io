<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Golang异常处理 | Ycchi0 Blog</title>
<meta name="keywords" content="">
<meta name="description" content="从error的定义说起 type error interface { Error() string } Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。
func main() { err := errors.New(&#34;a error&#34;) fmt.Println(reflect.TypeOf(err))//*errors.errorString } 可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？
// Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return &amp;errorString{text} } 查看errors包的代码，我们知道返回指针是为了确保err的唯一性。
以下的代码是返回一个变量会引起的问题。
type ValueError string func (ve ValueError) Error() string { return string(ve) } func New(text string) error { return ValueError(text) } func main() { simpleError := New(&#34;error&#34;) complexError := New(&#34;error&#34;) if simpleError == complexError { fmt.">
<meta name="author" content="">
<link rel="canonical" href="https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ycchi0.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ycchi0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ycchi0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ycchi0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ycchi0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Golang异常处理" />
<meta property="og:description" content="从error的定义说起 type error interface { Error() string } Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。
func main() { err := errors.New(&#34;a error&#34;) fmt.Println(reflect.TypeOf(err))//*errors.errorString } 可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？
// Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return &amp;errorString{text} } 查看errors包的代码，我们知道返回指针是为了确保err的唯一性。
以下的代码是返回一个变量会引起的问题。
type ValueError string func (ve ValueError) Error() string { return string(ve) } func New(text string) error { return ValueError(text) } func main() { simpleError := New(&#34;error&#34;) complexError := New(&#34;error&#34;) if simpleError == complexError { fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-05-28T11:02:44+00:00" />
<meta property="article:modified_time" content="2024-05-28T11:02:44+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Golang异常处理"/>
<meta name="twitter:description" content="从error的定义说起 type error interface { Error() string } Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。
func main() { err := errors.New(&#34;a error&#34;) fmt.Println(reflect.TypeOf(err))//*errors.errorString } 可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？
// Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return &amp;errorString{text} } 查看errors包的代码，我们知道返回指针是为了确保err的唯一性。
以下的代码是返回一个变量会引起的问题。
type ValueError string func (ve ValueError) Error() string { return string(ve) } func New(text string) error { return ValueError(text) } func main() { simpleError := New(&#34;error&#34;) complexError := New(&#34;error&#34;) if simpleError == complexError { fmt."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://ycchi0.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Golang异常处理",
      "item": "https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Golang异常处理",
  "name": "Golang异常处理",
  "description": "从error的定义说起 type error interface { Error() string } Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。\nfunc main() { err := errors.New(\u0026#34;a error\u0026#34;) fmt.Println(reflect.TypeOf(err))//*errors.errorString } 可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？\n// Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026amp;errorString{text} } 查看errors包的代码，我们知道返回指针是为了确保err的唯一性。\n以下的代码是返回一个变量会引起的问题。\ntype ValueError string func (ve ValueError) Error() string { return string(ve) } func New(text string) error { return ValueError(text) } func main() { simpleError := New(\u0026#34;error\u0026#34;) complexError := New(\u0026#34;error\u0026#34;) if simpleError == complexError { fmt.",
  "keywords": [
    
  ],
  "articleBody": "从error的定义说起 type error interface { Error() string } Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。\nfunc main() { err := errors.New(\"a error\") fmt.Println(reflect.TypeOf(err))//*errors.errorString } 可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？\n// Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return \u0026errorString{text} } 查看errors包的代码，我们知道返回指针是为了确保err的唯一性。\n以下的代码是返回一个变量会引起的问题。\ntype ValueError string func (ve ValueError) Error() string { return string(ve) } func New(text string) error { return ValueError(text) } func main() { simpleError := New(\"error\") complexError := New(\"error\") if simpleError == complexError { fmt.Println(\"true\")//true } } Panic 机制 Go 没有像其它语言一样提供 try…catch机制。在Java代码中，我们常见的就是写了一大段的逻辑，然后在外层进行try…catch 异常处理。在Go中，我们只有 error 和 panic 函数，这里主要介绍一下panic函数，通常我们是在程序碰见无法处理问题时才会考虑panic，比如除数为0了，这时候程序是会直接奔溃的。所以Go提供了 recover 函数，用来回复程序抛出的panic,我们可以在 recover 里进行日志、堆栈信息的记录，便于后续问题的排查。\n通常是在 defer 里进行 recover 的。\npackage main import \"fmt\" func main() { f() fmt.Println(\"Returned normally from f.\") } func f() { defer func() { if r := recover(); r != nil { fmt.Println(\"Recovered in f\", r) } }() panic(\"panic\") } web 服务一般会在最外层使用 recover 来避免因为异常导致程序奔溃的情况。比如 gin.Default() 这个方法中就默认使用了 recovery() 中间件。\n以下代码片段来自 gin 的recovery 方法\nreturn func(c *Context) { defer func() { if err := recover(); err != nil { // Check for a broken connection, as it is not really a // condition that warrants a panic stack trace. var brokenPipe bool if ne, ok := err.(*net.OpError); ok { if se, ok := ne.Err.(*os.SyscallError); ok { if strings.Contains(strings.ToLower(se.Error()), \"broken pipe\") || strings.Contains(strings.ToLower(se.Error()), \"connection reset by peer\") { brokenPipe = true } } } .... }() c.Next() } 这里要注意的是，很多人利用defer-recover这样的套路，实现了Go语言的’try-catch’，这其实是不太优雅的。个人觉得这有点违背 Go 异常处理的设计理念。\n错误类型（error types） 预定义错误 io 包中就定义了很多预定义的错误。最常见的可能就是EOF了。\nvar ErrShortBuffer = errors.New(\"short buffer\") var EOF = errors.New(\"EOF\") var ErrUnexpectedEOF = errors.New(\"unexpected EOF\") 使用这种方式一个缺点就是不够灵活，当我们需要使用预定错误的时候，我们通常需要通过判断错误的类型是否相匹配\n而在业务层中，我们通常返回错误的时候需要带上一些上下文信息，方便后续问题的排查。如果我们使用fmt.Errorf()，就会破坏调用者的类型判断。同时如果在业务层使用了预定义的错误，这时这个错误也必须是公共的，这将增加API的对外暴露的信息。同时调用方需要引用定义错误的这个包，增加了源代码层面的依赖关系。所以这个类型的错误一般是在标准库或者基础库中进行使用。\n自定义错误 type MyError struct { When time.Time What string } func (e *MyError) Error() string { return fmt.Sprintf(\"%v : %v\\n\", e.When, e.What) } func test() error { return \u0026MyError{When: time.Now(), What: \"test error\"} } func main() { err := test() switch err.(type) { case nil: fmt.Println(\"nil\") case *MyError: fmt.Println(\"MyError\") default: fmt.Println(\"unKnow\") } } 代码中通过断言转换这个类型。与特定错误相比，自定义的错误可以携带更多的上下文信息，但是本质上仍需要error类型为public。同样和调用者有强耦合。\n因此，使用我们要尽量避免在公共API中使用 error types。\nAssert errors for behaviour, not type 我们应该断言错误的特定行为，而不是它的类型。这个建议来自于 Dave 。\n调用方关注更多的地方是这个错误的行为，而不是这个错误的类型，所以提供方可以封装出特定错误类型的方法，只对外暴露这个方法而不暴露错误的类型。\nfunc isTimeout(err error) bool { type timeout interface { Timeout() bool } te, ok := err.(timeout) return ok \u0026\u0026 te.Timeout() } 错误处理 在Go中，我们经常写出这样的代码\nif err != nil { //do someting //return } 从程序的严谨性来讲，有错误的地方都是需要处理的。错误仅需要处理一次，如果认为需要交给调用者处理，则仅需要将错误信息返回。\npkg/errors GitHub地址\npkg/errors 是一个好用的第三方error包，兼容Go标准库，提供了一些非常有用的操作用于封装和处理错误。\ntype RawError struct { msg string } func (e *RawError) Error() string { return e.msg } func main() { rawError := \u0026RawError{msg: \"no such file or directory\"} fmt.Println(\"rawError:\", rawError) wrapError := errors.Wrap(rawError, \"a error occurred in xxxx,xxxxx\") fmt.Println(\"wrapError:\", wrapError) wrapwrapError := errors.Wrap(rawError, \"double wrap\") switch errors.Cause(wrapError).(type) { case *RawError: fmt.Println(\"the error type is *RawError \") default: fmt.Println(\"unknown\") } switch errors.Cause(wrapwrapError).(type) { case *RawError: fmt.Println(\"the error type is *RawError \") default: fmt.Println(\"unknown\") } } // rawError: no such file or directory // wrapError: a error occurred in xxxx,xxxxx: no such file or directory // the error type is *RawError // the error type is *RawError Go标准库 Go1.13为 errors 和 fmt 标准库包引入了新特性。\n// Unwrap returns the result of calling the Unwrap method on err, if err's // type contains an Unwrap method returning error. // Otherwise, Unwrap returns nil. func Unwrap(err error) error { u, ok := err.(interface { Unwrap() error }) if !ok { return nil } return u.Unwrap() } // Is reports whether any error in err's chain matches target. // // The chain consists of err itself followed by the sequence of errors obtained by // repeatedly calling Unwrap. func Is(err, target error) bool { if target == nil { return err == target } isComparable := reflectlite.TypeOf(target).Comparable() for { if isComparable \u0026\u0026 err == target { return true } if x, ok := err.(interface{ Is(error) bool }); ok \u0026\u0026 x.Is(target) { return true } // TODO: consider supporting target.Is(err). This would allow // user-definable predicates, but also may allow for coping with sloppy // APIs, thereby making it easier to get away with them. if err = Unwrap(err); err == nil { return false } } } // As finds the first error in err's chain that matches target, and if so, sets // target to that error value and returns true. Otherwise, it returns false. func As(err error, target interface{}) bool { if target == nil { panic(\"errors: target cannot be nil\") } val := reflectlite.ValueOf(target) typ := val.Type() if typ.Kind() != reflectlite.Ptr || val.IsNil() { panic(\"errors: target must be a non-nil pointer\") } targetType := typ.Elem() if targetType.Kind() != reflectlite.Interface \u0026\u0026 !targetType.Implements(errorType) { panic(\"errors: *target must be interface or implement error\") } for err != nil { if reflectlite.TypeOf(err).AssignableTo(targetType) { val.Elem().Set(reflectlite.ValueOf(err)) return true } if x, ok := err.(interface{ As(interface{}) bool }); ok \u0026\u0026 x.As(target) { return true } err = Unwrap(err) } return false } //示例 var rawError = errors.New(\"simple error\") func SimpleError() error { return rawError } func main() { simpleError := SimpleError() wrapE := fmt.Errorf(\"wrap error:%w\", simpleError) wrapWrapE := fmt.Errorf(\"wrapWrapE error:%w\", wrapE) fmt.Printf(\"err:%+v\\n\", wrapWrapE) fmt.Printf(\"errors.Unwrap(wrapWrapE):%+v\\n\", errors.Unwrap(wrapWrapE)) fmt.Printf(\"errors.Unwrap(errors.Unwrap(wrapWrapE)):%+v\\n\", errors.Unwrap(errors.Unwrap(wrapWrapE))) fmt.Println(\"errors.Is(err, rawError):\", errors.Is(wrapWrapE, rawError)) var errorValue error fmt.Println(\"errors.As(err, \u0026rawError):\", errors.As(wrapWrapE, \u0026errorValue)) fmt.Println(\"errorValue:\", errorValue) } ",
  "wordCount" : "805",
  "inLanguage": "en",
  "datePublished": "2024-05-28T11:02:44Z",
  "dateModified": "2024-05-28T11:02:44Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ycchi0 Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ycchi0.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ycchi0.github.io/" accesskey="h" title="Ycchi0 Blog (Alt + H)">Ycchi0 Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      Golang异常处理
    </h1>
    <div class="post-meta"><span title='2024-05-28 11:02:44 +0000 UTC'>May 28, 2024</span>

</div>
  </header> 
  <div class="post-content"><h2 id="从error的定义说起">从error的定义说起<a hidden class="anchor" aria-hidden="true" href="#从error的定义说起">#</a></h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">error</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;a error&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">err</span>))<span style="color:#75715e">//*errors.errorString
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Each call to New returns a distinct error value even if the text is identical.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">errorString</span>{<span style="color:#a6e22e">text</span>}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>查看errors包的代码，我们知道返回指针是为了确保err的唯一性。</p>
<p>以下的代码是返回一个变量会引起的问题。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">ValueError</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">ve</span> <span style="color:#a6e22e">ValueError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> string(<span style="color:#a6e22e">ve</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">New</span>(<span style="color:#a6e22e">text</span> <span style="color:#66d9ef">string</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#a6e22e">text</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">simpleError</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;error&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">complexError</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;error&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">simpleError</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">complexError</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;true&#34;</span>)<span style="color:#75715e">//true
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="panic-机制">Panic 机制<a hidden class="anchor" aria-hidden="true" href="#panic-机制">#</a></h2>
<p>Go 没有像其它语言一样提供 try&hellip;catch机制。在Java代码中，我们常见的就是写了一大段的逻辑，然后在外层进行try&hellip;catch 异常处理。在Go中，我们只有 error 和 panic 函数，这里主要介绍一下panic函数，通常我们是在程序碰见无法处理问题时才会考虑panic，比如除数为0了，这时候程序是会直接奔溃的。所以Go提供了 recover 函数，用来回复程序抛出的panic,我们可以在 recover 里进行日志、堆栈信息的记录，便于后续问题的排查。</p>
<p>通常是在 defer 里进行 recover 的。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> <span style="color:#e6db74">&#34;fmt&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">f</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Returned normally from f.&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">f</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">r</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">r</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Recovered in f&#34;</span>, <span style="color:#a6e22e">r</span>)
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}()
</span></span><span style="display:flex;"><span>	panic(<span style="color:#e6db74">&#34;panic&#34;</span>)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>web 服务一般会在最外层使用 recover 来避免因为异常导致程序奔溃的情况。比如 gin.Default() 这个方法中就默认使用了 recovery() 中间件。</p>
<p>以下代码片段来自 gin 的recovery 方法</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">return</span> <span style="color:#66d9ef">func</span>(<span style="color:#a6e22e">c</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">Context</span>) {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">defer</span> <span style="color:#66d9ef">func</span>() {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> recover(); <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>				<span style="color:#75715e">// Check for a broken connection, as it is not really a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#75715e">// condition that warrants a panic stack trace.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>				<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">brokenPipe</span> <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>				<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">ne</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">net</span>.<span style="color:#a6e22e">OpError</span>); <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>					<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">se</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">ne</span>.<span style="color:#a6e22e">Err</span>.(<span style="color:#f92672">*</span><span style="color:#a6e22e">os</span>.<span style="color:#a6e22e">SyscallError</span>); <span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>						<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">se</span>.<span style="color:#a6e22e">Error</span>()), <span style="color:#e6db74">&#34;broken pipe&#34;</span>) <span style="color:#f92672">||</span> <span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">Contains</span>(<span style="color:#a6e22e">strings</span>.<span style="color:#a6e22e">ToLower</span>(<span style="color:#a6e22e">se</span>.<span style="color:#a6e22e">Error</span>()), <span style="color:#e6db74">&#34;connection reset by peer&#34;</span>) {
</span></span><span style="display:flex;"><span>							<span style="color:#a6e22e">brokenPipe</span> = <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>						}
</span></span><span style="display:flex;"><span>					}
</span></span><span style="display:flex;"><span>				}
</span></span><span style="display:flex;"><span>				<span style="color:#f92672">...</span>.
</span></span><span style="display:flex;"><span>		}()
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Next</span>()
</span></span><span style="display:flex;"><span>	}
</span></span></code></pre></div><p>这里要注意的是，很多人利用defer-recover这样的套路，实现了Go语言的&rsquo;try-catch&rsquo;，这其实是不太优雅的。个人觉得这有点违背 Go 异常处理的设计理念。</p>
<h2 id="错误类型error-types">错误类型（error types）<a hidden class="anchor" aria-hidden="true" href="#错误类型error-types">#</a></h2>
<h3 id="预定义错误">预定义错误<a hidden class="anchor" aria-hidden="true" href="#预定义错误">#</a></h3>
<p>io 包中就定义了很多预定义的错误。最常见的可能就是EOF了。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ErrShortBuffer</span> = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;short buffer&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">EOF</span> = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;EOF&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">ErrUnexpectedEOF</span> = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;unexpected EOF&#34;</span>)
</span></span></code></pre></div><p>使用这种方式一个缺点就是不够灵活，当我们需要使用预定错误的时候，我们通常需要通过判断错误的类型是否相匹配</p>
<p>而在业务层中，我们通常返回错误的时候需要带上一些上下文信息，方便后续问题的排查。如果我们使用fmt.Errorf()，就会破坏调用者的类型判断。同时如果在业务层使用了预定义的错误，这时这个错误也必须是公共的，这将增加API的对外暴露的信息。同时调用方需要引用定义错误的这个包，增加了源代码层面的依赖关系。所以这个类型的错误一般是在标准库或者基础库中进行使用。</p>
<h3 id="自定义错误">自定义错误<a hidden class="anchor" aria-hidden="true" href="#自定义错误">#</a></h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">MyError</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">When</span> <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Time</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">What</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MyError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Sprintf</span>(<span style="color:#e6db74">&#34;%v : %v\n&#34;</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">When</span>, <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">What</span>)
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">test</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">MyError</span>{<span style="color:#a6e22e">When</span>: <span style="color:#a6e22e">time</span>.<span style="color:#a6e22e">Now</span>(), <span style="color:#a6e22e">What</span>: <span style="color:#e6db74">&#34;test error&#34;</span>}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">err</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">test</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">err</span>.(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#66d9ef">nil</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;nil&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">MyError</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;MyError&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unKnow&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>代码中通过断言转换这个类型。与特定错误相比，自定义的错误可以携带更多的上下文信息，但是本质上仍需要error类型为public。同样和调用者有强耦合。</p>
<p>因此，使用我们要尽量避免在公共API中使用 error types。</p>
<h3 id="assert-errors-for-behaviour-not-type">Assert errors for behaviour, not type<a hidden class="anchor" aria-hidden="true" href="#assert-errors-for-behaviour-not-type">#</a></h3>
<p>我们应该断言错误的特定行为，而不是它的类型。这个建议来自于 <a href="https://link.zhihu.com/?target=https%3A//dave.cheney.net/2014/12/24/inspecting-errors">Dave</a> 。</p>
<p>调用方关注更多的地方是这个错误的行为，而不是这个错误的类型，所以提供方可以封装出特定错误类型的方法，只对外暴露这个方法而不暴露错误的类型。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">isTimeout</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">timeout</span> <span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>                <span style="color:#a6e22e">Timeout</span>() <span style="color:#66d9ef">bool</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">te</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#a6e22e">timeout</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">te</span>.<span style="color:#a6e22e">Timeout</span>()
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h2 id="错误处理">错误处理<a hidden class="anchor" aria-hidden="true" href="#错误处理">#</a></h2>
<p>在Go中，我们经常写出这样的代码</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>   <span style="color:#75715e">//do someting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>   <span style="color:#75715e">//return 
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>从程序的严谨性来讲，有错误的地方都是需要处理的。错误仅需要处理一次，如果认为需要交给调用者处理，则仅需要将错误信息返回。</p>
<h3 id="pkgerrors">pkg/errors<a hidden class="anchor" aria-hidden="true" href="#pkgerrors">#</a></h3>
<p><a href="https://link.zhihu.com/?target=https%3A//github.com/pkg/errors">GitHub地址</a></p>
<p>pkg/errors 是一个好用的第三方error包，兼容Go标准库，提供了一些非常有用的操作用于封装和处理错误。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">RawError</span> <span style="color:#66d9ef">struct</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">msg</span> <span style="color:#66d9ef">string</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> (<span style="color:#a6e22e">e</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RawError</span>) <span style="color:#a6e22e">Error</span>() <span style="color:#66d9ef">string</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">e</span>.<span style="color:#a6e22e">msg</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">rawError</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">RawError</span>{<span style="color:#a6e22e">msg</span>: <span style="color:#e6db74">&#34;no such file or directory&#34;</span>}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;rawError:&#34;</span>, <span style="color:#a6e22e">rawError</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wrapError</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Wrap</span>(<span style="color:#a6e22e">rawError</span>, <span style="color:#e6db74">&#34;a error occurred in xxxx,xxxxx&#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;wrapError:&#34;</span>, <span style="color:#a6e22e">wrapError</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wrapwrapError</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Wrap</span>(<span style="color:#a6e22e">rawError</span>, <span style="color:#e6db74">&#34;double wrap&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Cause</span>(<span style="color:#a6e22e">wrapError</span>).(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RawError</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;the error type is *RawError &#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unknown&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">switch</span> <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Cause</span>(<span style="color:#a6e22e">wrapwrapError</span>).(<span style="color:#66d9ef">type</span>) {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">case</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">RawError</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;the error type is *RawError &#34;</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">default</span>:
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;unknown&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// rawError: no such file or directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// wrapError: a error occurred in xxxx,xxxxx: no such file or directory
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the error type is *RawError
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// the error type is *RawError
</span></span></span></code></pre></div><h3 id="go标准库">Go标准库<a hidden class="anchor" aria-hidden="true" href="#go标准库">#</a></h3>
<p>Go1.13为 errors 和 fmt 标准库包引入了新特性。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-go" data-lang="go"><span style="display:flex;"><span><span style="color:#75715e">// Unwrap returns the result of calling the Unwrap method on err, if err&#39;s
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// type contains an Unwrap method returning error.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// Otherwise, Unwrap returns nil.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Unwrap</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">u</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#66d9ef">interface</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">Unwrap</span>() <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	})
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> !<span style="color:#a6e22e">ok</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">nil</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">u</span>.<span style="color:#a6e22e">Unwrap</span>()
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// Is reports whether any error in err&#39;s chain matches target.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">//
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// The chain consists of err itself followed by the sequence of errors obtained by
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// repeatedly calling Unwrap.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">err</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span>
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">isComparable</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflectlite</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">target</span>).<span style="color:#a6e22e">Comparable</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">isComparable</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#a6e22e">target</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#66d9ef">interface</span>{ <span style="color:#a6e22e">Is</span>(<span style="color:#66d9ef">error</span>) <span style="color:#66d9ef">bool</span> }); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">target</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#75715e">// TODO: consider supporting target.Is(err). This would allow
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// user-definable predicates, but also may allow for coping with sloppy
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#75715e">// APIs, thereby making it easier to get away with them.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">Unwrap</span>(<span style="color:#a6e22e">err</span>); <span style="color:#a6e22e">err</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// As finds the first error in err&#39;s chain that matches target, and if so, sets
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">// target to that error value and returns true. Otherwise, it returns false.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">As</span>(<span style="color:#a6e22e">err</span> <span style="color:#66d9ef">error</span>, <span style="color:#a6e22e">target</span> <span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;errors: target cannot be nil&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">val</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflectlite</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">target</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">typ</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">Type</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">Kind</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">reflectlite</span>.<span style="color:#a6e22e">Ptr</span> <span style="color:#f92672">||</span> <span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">IsNil</span>() {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;errors: target must be a non-nil pointer&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">targetType</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">typ</span>.<span style="color:#a6e22e">Elem</span>()
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">targetType</span>.<span style="color:#a6e22e">Kind</span>() <span style="color:#f92672">!=</span> <span style="color:#a6e22e">reflectlite</span>.<span style="color:#a6e22e">Interface</span> <span style="color:#f92672">&amp;&amp;</span> !<span style="color:#a6e22e">targetType</span>.<span style="color:#a6e22e">Implements</span>(<span style="color:#a6e22e">errorType</span>) {
</span></span><span style="display:flex;"><span>		panic(<span style="color:#e6db74">&#34;errors: *target must be interface or implement error&#34;</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">for</span> <span style="color:#a6e22e">err</span> <span style="color:#f92672">!=</span> <span style="color:#66d9ef">nil</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">reflectlite</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">err</span>).<span style="color:#a6e22e">AssignableTo</span>(<span style="color:#a6e22e">targetType</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#a6e22e">val</span>.<span style="color:#a6e22e">Elem</span>().<span style="color:#a6e22e">Set</span>(<span style="color:#a6e22e">reflectlite</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">err</span>))
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#66d9ef">if</span> <span style="color:#a6e22e">x</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">err</span>.(<span style="color:#66d9ef">interface</span>{ <span style="color:#a6e22e">As</span>(<span style="color:#66d9ef">interface</span>{}) <span style="color:#66d9ef">bool</span> }); <span style="color:#a6e22e">ok</span> <span style="color:#f92672">&amp;&amp;</span> <span style="color:#a6e22e">x</span>.<span style="color:#a6e22e">As</span>(<span style="color:#a6e22e">target</span>) {
</span></span><span style="display:flex;"><span>			<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span>
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		<span style="color:#a6e22e">err</span> = <span style="color:#a6e22e">Unwrap</span>(<span style="color:#a6e22e">err</span>)
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">//示例
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">var</span> <span style="color:#a6e22e">rawError</span> = <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">New</span>(<span style="color:#e6db74">&#34;simple error&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">SimpleError</span>() <span style="color:#66d9ef">error</span> {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">rawError</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">simpleError</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">SimpleError</span>()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wrapE</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;wrap error:%w&#34;</span>, <span style="color:#a6e22e">simpleError</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">wrapWrapE</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Errorf</span>(<span style="color:#e6db74">&#34;wrapWrapE error:%w&#34;</span>, <span style="color:#a6e22e">wrapE</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;err:%+v\n&#34;</span>, <span style="color:#a6e22e">wrapWrapE</span>)
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;errors.Unwrap(wrapWrapE):%+v\n&#34;</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Unwrap</span>(<span style="color:#a6e22e">wrapWrapE</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;errors.Unwrap(errors.Unwrap(wrapWrapE)):%+v\n&#34;</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Unwrap</span>(<span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Unwrap</span>(<span style="color:#a6e22e">wrapWrapE</span>)))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;errors.Is(err, rawError):&#34;</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">Is</span>(<span style="color:#a6e22e">wrapWrapE</span>, <span style="color:#a6e22e">rawError</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">errorValue</span> <span style="color:#66d9ef">error</span>
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;errors.As(err, &amp;rawError):&#34;</span>, <span style="color:#a6e22e">errors</span>.<span style="color:#a6e22e">As</span>(<span style="color:#a6e22e">wrapWrapE</span>, <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">errorValue</span>))
</span></span><span style="display:flex;"><span>	<span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;errorValue:&#34;</span>, <span style="color:#a6e22e">errorValue</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://ycchi0.github.io/">Ycchi0 Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
