<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Ycchi0 Blog</title>
    <link>https://ycchi0.github.io/posts/</link>
    <description>Recent content in Posts on Ycchi0 Blog</description>
    <generator>Hugo</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 22 Oct 2024 02:22:35 +0000</lastBuildDate>
    <atom:link href="https://ycchi0.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>单体应用的痛点</title>
      <link>https://ycchi0.github.io/posts/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E7%9A%84%E7%97%9B%E7%82%B9/</link>
      <pubDate>Tue, 22 Oct 2024 02:22:35 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%E7%9A%84%E7%97%9B%E7%82%B9/</guid>
      <description>单体应用是一种将所有功能模块和业务逻辑整合在一个应用程序中的架构模式。&#xA;这种架构适用于初期开发阶段和小型项目，但随着应用规模的增长，单体应用会暴露出一系列痛点：&#xA;1. 难以扩展 水平扩展：单体应用难以单独扩展某一部分，通常需要对整个应用进行扩展，即使某些功能模块并不需要更多的资源。 功能模块耦合：不同模块之间的强耦合使得难以拆分，导致即便是小的功能变更，也可能对整个系统产生影响。 2. 发布与部署复杂 统一部署：所有模块共同部署，意味着即便是一个小的改动（如修复一个小问题或更新某个模块），整个应用都需要重新构建、测试和发布，这大大增加了发布的风险和成本。 持续集成压力：随着代码库的增大，单体应用的构建和测试时间也会显著增加，拖慢开发进度。 3. 难以维护和更新 代码膨胀：随着功能的不断增加，代码库可能会变得庞大而复杂，使得开发人员难以理解整个系统。一个新的开发人员需要花费很长时间才能熟悉整个应用。 技术栈受限：由于所有模块都依赖于相同的技术栈和框架，某些模块可能需要升级或重写，而整个应用的统一技术栈可能会阻碍这一进程。 4. 可靠性问题 单点故障：如果单体应用的某一部分出错或发生性能问题，可能会导致整个应用的不可用。无法实现模块级别的故障隔离。 维护成本高：维护一个大而复杂的单体应用要求开发团队具备广泛的技能，因为团队必须处理多种不同的功能、模块以及它们之间的相互依赖关系。 5. 开发速度瓶颈 团队协作受限：随着团队的壮大，多个开发人员在同一个代码库上工作可能会带来冲突，并且不同模块之间的依赖关系使得开发、测试和合并变得更加困难。 难以引入新的技术：由于单体应用的紧耦合性，很难在不影响现有功能的情况下引入新技术，或者迁移到更先进的架构或框架。 6. 测试和调试困难 全面测试需求：由于单体应用的复杂性，任何代码的修改都可能影响多个模块，因此需要进行全面的回归测试，测试时间长且成本高。 难以调试：应用出错时，往往需要排查整个系统，增加了调试的难度。 7. 难以满足不同团队的需求 规模化团队的协作问题：当多个团队需要同时对单体应用进行开发和维护时，协调难度加大，容易产生开发瓶颈，尤其是在不同团队的职责和需求发生冲突时。 总结： 单体应用在早期开发时非常高效，适合快速交付和验证产品。但随着应用规模和复杂性的增加，单体架构往往会成为发展的瓶颈。现代软件开发越来越倾向于采用微服务架构来应对这些痛点，以实现模块的独立开发、测试、部署和扩展，从而提高系统的灵活性和可维护性。</description>
    </item>
    <item>
      <title>gRPC错误处理</title>
      <link>https://ycchi0.github.io/posts/grpc%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 21 Oct 2024 09:24:36 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/grpc%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>gRPC 中的错误处理是一个关键的部分，用于确保在客户端和服务器之间进行高效的错误传递和处理。与传统的 HTTP API 不同，gRPC 依赖 Protocol Buffers 来定义消息和错误信息。gRPC 错误处理不仅包括返回错误码，还提供了扩展的错误信息，便于调试、记录日志和实现更丰富的业务逻辑。&#xA;gRPC 错误码 gRPC 使用 状态码（Status Code） 来表示错误。gRPC 错误码基于 HTTP/2 的状态码，但有自己的定义。常用的 gRPC 状态码包括：&#xA;状态码 含义 解释 OK 成功 请求成功完成，结果符合预期。 CANCELLED 客户端取消请求 通常由客户端或服务器在取消操作时返回。 UNKNOWN 未知错误 服务器发生了未知的错误，通常伴随服务器崩溃等问题。 INVALID_ARGUMENT 参数无效 客户端发送的请求中包含非法参数。 DEADLINE_EXCEEDED 请求超时 请求未在预定的时间内完成，可能由于网络延迟或服务器负载高。 NOT_FOUND 未找到 请求的资源不存在。 ALREADY_EXISTS 资源已存在 尝试创建一个已存在的资源时返回。 PERMISSION_DENIED 权限不足 客户端没有足够的权限访问资源。 UNAUTHENTICATED 未认证 客户端未提供身份验证信息，或者身份验证失败。 RESOURCE_EXHAUSTED 资源耗尽 通常表示服务器的资源不足，可能是限流或磁盘、内存等资源不足。 FAILED_PRECONDITION 操作状态错误 请求无法在当前系统状态下执行。 ABORTED 操作中止 请求被服务器中止，通常是由于并发冲突。 OUT_OF_RANGE 超出有效范围 请求的值超出了允许的范围。 UNIMPLEMENTED 未实现 请求的方法尚未在服务器中实现。 INTERNAL 内部错误 服务器内部逻辑出错，类似于 HTTP 的 500 状态码。 UNAVAILABLE 服务不可用 服务器当前不可用，通常是由于过载或临时故障。 DATA_LOSS 数据丢失 不可恢复的数据丢失，表示非常严重的系统错误。 Go 中的 gRPC 错误处理 在 Go 中，gRPC 提供了 status 包来处理错误，并允许开发者定义自定义错误码和错误消息。以下是 gRPC 错误处理的常见方法。</description>
    </item>
    <item>
      <title>ProtoBuf验证器</title>
      <link>https://ycchi0.github.io/posts/protobuf%E9%AA%8C%E8%AF%81%E5%99%A8/</link>
      <pubDate>Mon, 21 Oct 2024 09:17:20 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/protobuf%E9%AA%8C%E8%AF%81%E5%99%A8/</guid>
      <description>protoc-gen-validate（PGV）是一个流行的 Protobuf 验证器插件，用于自动生成验证代码，帮助开发者在服务端和客户端对 Protobuf 消息进行有效性检查。&#xA;为什么需要 Protobuf 验证器？ 在使用 Protobuf 定义 gRPC 接口时，虽然 Protobuf 定义了数据的结构和类型，但并没有内置的机制对具体值进行详细验证（如字段长度、格式、范围等）。&#xA;在生产环境中，数据的有效性对于系统的稳定性和安全性至关重要。protoc-gen-validate 提供了一种在 .proto 文件中直接定义验证规则的方式，并生成相应的验证代码，确保数据符合业务需求。&#xA;protoc-gen-validate 的特点 自动化验证：基于 Protobuf 规范的字段验证，无需手动编写大量验证逻辑。 丰富的验证规则：支持多种类型（字符串、数值、集合等）的验证规则，包括范围、长度、正则表达式等。 跨语言支持：生成多种语言的验证代码（如 Go、C++、Java、Python 等），便于在跨语言系统中统一验证逻辑。 与 Protobuf 无缝集成：验证规则直接定义在 Protobuf .proto 文件中，开发者可以轻松理解和维护。 轻量级：通过生成的代码实现高效的验证逻辑，不增加运行时开销。 安装及使用 https://github.com/bufbuild/protoc-gen-validate?tab=readme-ov-file#usage</description>
    </item>
    <item>
      <title>gRPC拦截器</title>
      <link>https://ycchi0.github.io/posts/grpc%E6%8B%A6%E6%88%AA%E5%99%A8/</link>
      <pubDate>Mon, 21 Oct 2024 08:38:36 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/grpc%E6%8B%A6%E6%88%AA%E5%99%A8/</guid>
      <description>在 gRPC 中，拦截器（Interceptor） 是一种用于在客户端或服务器上实现通用功能的机制，类似于中间件的概念。通过拦截器，你可以在 gRPC 方法调用之前或之后执行额外的逻辑，例如认证、日志记录、监控、限流等。&#xA;gRPC 支持两种拦截器：&#xA;一元拦截器（Unary Interceptor）：拦截一元（Unary）调用，也就是客户端发送一个请求，服务器返回一个响应的调用。 流式拦截器（Stream Interceptor）：拦截流式（Streaming）调用，适用于客户端、服务器或双向流的调用。 拦截器的使用场景 日志记录：记录每个 gRPC 调用的细节，如请求参数、响应时间等。 身份认证：验证每个 gRPC 请求是否携带有效的认证信息。 限流和节流：在服务高负载的情况下对请求进行限流或节流。 错误处理：统一处理错误并进行转换或记录。 监控和追踪：通过拦截器添加监控逻辑，用于跟踪请求的性能或传递分布式追踪信息。 拦截器在 Go 中的实现 server&#xA;/* * * Copyright 2022 gRPC authors. * * Licensed under the Apache License, Version 2.0 (the &amp;#34;License&amp;#34;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &amp;#34;AS IS&amp;#34; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</description>
    </item>
    <item>
      <title>gRPC的metadata</title>
      <link>https://ycchi0.github.io/posts/grpc%E7%9A%84metadata/</link>
      <pubDate>Mon, 21 Oct 2024 08:03:34 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/grpc%E7%9A%84metadata/</guid>
      <description>在 gRPC 的 Go 语言实现中，metadata 也是一个重要的概念，主要用于在客户端和服务端之间传递键值对形式的附加信息。&#xA;以下将详细介绍在 Go 语言中如何使用 gRPC Metadata，以及它的典型使用场景和注意事项。&#xA;gRPC Metadata 在 Go 语言中的使用 1. 客户端发送 Metadata 示例 1：&#xA;// create a new context with some metadata ctx := metadata.AppendToOutgoingContext(ctx, &amp;#34;k1&amp;#34;, &amp;#34;v1&amp;#34;, &amp;#34;k1&amp;#34;, &amp;#34;v2&amp;#34;, &amp;#34;k2&amp;#34;, &amp;#34;v3&amp;#34;) // later, add some more metadata to the context (e.g. in an interceptor) ctx := metadata.AppendToOutgoingContext(ctx, &amp;#34;k3&amp;#34;, &amp;#34;v4&amp;#34;) // make unary RPC response, err := client.SomeRPC(ctx, someRequest) // or make streaming RPC stream, err := client.</description>
    </item>
    <item>
      <title>option go_package</title>
      <link>https://ycchi0.github.io/posts/protobuf-option-go_package/</link>
      <pubDate>Mon, 21 Oct 2024 06:28:37 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/protobuf-option-go_package/</guid>
      <description>1. option go_package option go_package 用于指定 .proto 文件生成的 Go 代码应该属于哪个包（package）。它的主要作用是为生成的 Go 代码指定正确的导入路径，特别是在项目有多个模块时，能够避免不同 .proto 文件生成的代码包名冲突。&#xA;语法： option go_package = &amp;#34;path/to/your/package&amp;#34;; 作用： 指定 Go 包路径：当你在 .proto 文件中设置 go_package 选项时，生成的 Go 代码会按照你指定的路径进行包名和包导入的管理。 防止包冲突：在大型项目中，如果不同的 .proto 文件中定义了相同的消息或服务，设置 go_package 可以将它们分别放入不同的包，避免包冲突。 模块化管理：在 Go Modules 项目中，正确设置 go_package 可以确保生成的代码在导入时符合 Go Module 的规范，使得依赖管理更加方便。 示例： 假设你有一个 .proto 文件，内容如下：&#xA;syntax = &amp;#34;proto3&amp;#34;; option go_package = &amp;#34;github.com/example/project/proto/user&amp;#34;; message User { string name = 1; int32 age = 2; } 在上面的例子中，设置了 option go_package = &amp;quot;github.</description>
    </item>
    <item>
      <title>ProtoBuf跟Json对比</title>
      <link>https://ycchi0.github.io/posts/protobuf%E8%B7%9Fjson%E5%AF%B9%E6%AF%94/</link>
      <pubDate>Mon, 21 Oct 2024 04:30:50 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/protobuf%E8%B7%9Fjson%E5%AF%B9%E6%AF%94/</guid>
      <description>在 Go 语言中，使用 Protocol Buffers (Protobuf) 和 JSON 进行数据序列化和反序列化是常见的两种方式。两者各有优缺点，适用于不同的场景。我们可以通过以下几个维度进行对比，并结合 Go 语言的使用示例来说明。&#xA;1. 数据格式 Protobuf：二进制格式，紧凑、占用空间少，适合对性能和带宽敏感的应用场景。 JSON：文本格式，易于阅读和调试，适合需要人类可读性的场景，如 REST API。 2. 序列化和反序列化性能 Protobuf：由于是二进制格式，序列化和反序列化的速度通常比 JSON 快，特别是对复杂或大规模的数据结构而言。它更加高效且占用内存较少。 JSON：由于是文本格式，解析速度相对较慢，尤其是在处理大量数据时。虽然 JSON 易读，但在性能上不如 Protobuf 高效。 3. 向后兼容性 Protobuf：向后兼容性非常好，能够在不破坏现有系统的情况下增加新的字段。旧客户端可以忽略新字段，而新客户端可以处理旧数据。 JSON：JSON 没有内置的强向后兼容性机制。添加或删除字段可能会导致客户端和服务器之间的数据解析出错，需要额外的逻辑处理。 4. 文件大小 Protobuf：由于是二进制格式，通常生成的文件更小，适合对网络带宽要求较高的场景。 JSON：由于是纯文本格式，生成的文件通常较大，尤其是当字段名和嵌套结构很多时。 5. 生态与支持 Protobuf：需要定义 .proto 文件来描述数据结构，开发工具会自动生成 Go 代码，但需要额外的编译步骤。Protobuf 适用于 gRPC 等高效通信场景。 JSON：Go 原生支持 JSON，使用方便，不需要额外的编译步骤。广泛用于 Web API 和轻量级数据交换。 对比总结 特性 Protobuf JSON 数据格式 二进制格式，紧凑 文本格式，人类可读 序列化/反序列化速度 快，高效 相对较慢 文件大小 小，占用带宽低 较大 向后兼容性 内置强向后兼容性 需手动处理 生态支持 需要编译 proto 文件生成代码 Go 原生支持，使用简单 适用场景 高性能分布式系统，带宽敏感应用 Web API，调试友好，轻量级数据交换 选择建议：</description>
    </item>
    <item>
      <title>什么是Grpc跟ProtoBuf?</title>
      <link>https://ycchi0.github.io/posts/%E4%BB%80%E4%B9%88%E6%98%AFgrpc%E8%B7%9Fprotobuf/</link>
      <pubDate>Mon, 21 Oct 2024 04:05:15 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E4%BB%80%E4%B9%88%E6%98%AFgrpc%E8%B7%9Fprotobuf/</guid>
      <description>gRPC 和 Protocol Buffers (Protobuf) 经常一起使用来构建高性能的分布式系统。下面我们详细了解一下这两者及其关系：&#xA;1. gRPC (Google Remote Procedure Call) gRPC 是一个现代的、开源的远程过程调用 (Remote Procedure Call, RPC) 框架，允许客户端和服务器之间进行高效的通信。它的主要特点包括：&#xA;多语言支持：gRPC 支持多种编程语言，如 C++, Java, Python, Go, Ruby 等。因此，开发者可以在不同语言间进行无缝通信。 基于 HTTP/2：gRPC 使用 HTTP/2 作为底层传输协议，支持特性如多路复用、流式传输、压缩和请求优先级，能在同一连接上处理多个请求和响应。 跨平台通信：gRPC 可以让不同平台（如 Android, iOS, Web 应用）之间进行跨平台通信。 高效的序列化/反序列化：gRPC 通常与 Protocol Buffers 一起使用，用于高效的数据序列化和反序列化。 多种通信模式：gRPC 提供四种通信模式：一元 (Unary RPC)、服务器流式 (Server-side streaming)、客户端流式 (Client-side streaming) 和双向流式 (Bidirectional streaming)。 自动代码生成：gRPC 提供的工具可以根据 .proto 文件自动生成客户端和服务端的代码，减少了重复性开发工作。 2. Protocol Buffers (Protobuf) Protocol Buffers 是一种语言中立、平台中立的数据序列化格式，用于高效地结构化数据的编码。Protobuf 也是 gRPC 的默认序列化格式。其主要特点包括：&#xA;高效性：Protobuf 的二进制格式非常紧凑，序列化和反序列化速度都很快，适合高性能场景。</description>
    </item>
    <item>
      <title>030Go并发-读写锁</title>
      <link>https://ycchi0.github.io/posts/030go%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Sat, 19 Oct 2024 09:15:04 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/030go%E5%B9%B6%E5%8F%91-%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>在 Go 语言的并发编程中，读写锁（RWMutex） 是一种高级锁机制，允许在某些情况下进行并发的读操作，而在需要修改共享资源时进行写操作时加以保护。相比于普通的互斥锁（Mutex），读写锁允许多个 Goroutine 同时进行读操作，只有在写操作时会阻止其他 Goroutine 访问共享资源。&#xA;sync.RWMutex 是 Go 标准库中提供的读写锁实现。&#xA;读写锁的工作原理 sync.RWMutex 提供了两种锁模式：&#xA;读锁（RLock）：当一个 Goroutine 获得读锁时，其他 Goroutine 也可以获取读锁并进行并发读取操作。然而，写操作在读锁未释放前是被阻塞的。 写锁（Lock）：当一个 Goroutine 获得写锁时，所有的读操作和写操作都被阻塞，直到写锁被释放。 读写锁的设计思路是：读多写少的场景下，通过允许并发的读操作来提高性能，而在写操作发生时，需要锁住所有操作来保证数据的一致性。&#xA;读写锁的主要方法 RLock()：获取读锁，允许多个 Goroutine 同时进行读取操作。 RUnlock()：释放读锁，表示当前 Goroutine 读取操作已完成。 Lock()：获取写锁，只有一个 Goroutine 能获得写锁，其他的读写操作都会被阻塞。 Unlock()：释放写锁，允许其他 Goroutine 获取读锁或写锁。 读写锁的使用示例 假设我们有一个共享资源，并且多个 Goroutine 会频繁读取这个资源，但偶尔会有一些 Goroutine 需要更新该资源。在这种情况下，我们可以使用 RWMutex 来优化性能，允许并发读取操作，同时确保写操作的正确性。&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) var ( rwMutex sync.RWMutex counter int ) func read(wg *sync.WaitGroup, id int) { defer wg.Done() rwMutex.RLock() // 获取读锁 fmt.</description>
    </item>
    <item>
      <title>029Go并发-Mutex和atomic</title>
      <link>https://ycchi0.github.io/posts/029go%E5%B9%B6%E5%8F%91-mutex%E5%92%8Catomic/</link>
      <pubDate>Sat, 19 Oct 2024 08:09:09 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/029go%E5%B9%B6%E5%8F%91-mutex%E5%92%8Catomic/</guid>
      <description>在并发编程中，当多个 Goroutine 同时访问或修改共享变量时，会导致数据竞争（race condition）的问题。为了解决这种问题，Go 提供了两种主要的方法来保证对共享资源的原子性操作：一种是使用 sync.Mutex（互斥锁），另一种是使用 sync/atomic 包提供的原子操作。&#xA;这两种方式各有优缺点，适用于不同的场景。接下来，我将分别介绍它们的工作原理、使用方法以及适用场景。&#xA;1. sync.Mutex（互斥锁） 工作原理 sync.Mutex 是一种常用的锁机制，通过互斥锁来确保同一时刻只有一个 Goroutine 能访问某个共享资源。其他试图访问该资源的 Goroutine 必须等待，直到锁被释放。通过加锁和解锁，Mutex 可以确保对共享资源的操作是原子的，不会出现并发修改导致的数据不一致问题。&#xA;关键方法 Lock()：当某个 Goroutine 调用 Lock() 时，如果其他 Goroutine 已经持有了这把锁，它将阻塞，直到锁被释放。 Unlock()：解锁，让其他 Goroutine 可以继续获取该锁。Unlock() 必须由当前持有锁的 Goroutine 调用。 示例代码 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; ) var ( counter int mu sync.Mutex ) func increment(wg *sync.WaitGroup) { defer wg.Done() mu.Lock() // 加锁，保护对共享变量 counter 的访问 counter++ mu.Unlock() // 解锁 } func main() { var wg sync.WaitGroup for i := 0; i &amp;lt; 1000; i++ { wg.</description>
    </item>
    <item>
      <title>028Go并发-WaitGroup</title>
      <link>https://ycchi0.github.io/posts/028go%E5%B9%B6%E5%8F%91--waitgroup/</link>
      <pubDate>Sat, 19 Oct 2024 08:04:42 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/028go%E5%B9%B6%E5%8F%91--waitgroup/</guid>
      <description>在 Go 语言中，sync.WaitGroup 是一种用于并发同步的工具，能够帮助我们等待一组 Goroutine 完成执行。当我们在一个函数中启动多个并发任务（Goroutine）时，常常需要在主 Goroutine 等待这些并发任务完成，WaitGroup 能很好地解决这个问题。&#xA;WaitGroup 的基本原理 WaitGroup 通过一个计数器来追踪并发任务的数量。每启动一个 Goroutine，计数器加一，每个 Goroutine 结束时，计数器减一。主 Goroutine 调用 Wait() 方法阻塞自己，直到计数器归零，表示所有的 Goroutine 都已经完成工作。&#xA;WaitGroup 的核心方法 Add(delta int)：将 WaitGroup 的计数器增加 delta，通常是正数，表示增加要等待的 Goroutine 数量。&#xA;Done()：将计数器减一，表示一个 Goroutine 已经完成。它是 Add(-1) 的简写。&#xA;Wait()：阻塞当前 Goroutine，直到 WaitGroup 的计数器变为 0，表示所有 Goroutine 都已完成。&#xA;WaitGroup 使用示例 以下是一个典型的 WaitGroup 使用示例：&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;sync&amp;#34; &amp;#34;time&amp;#34; ) func worker(id int, wg *sync.WaitGroup) { defer wg.Done() // Goroutine 完成时调用 Done() fmt.Printf(&amp;#34;Worker %d starting\n&amp;#34;, id) time.</description>
    </item>
    <item>
      <title>027Go并发-GMP模型</title>
      <link>https://ycchi0.github.io/posts/027go%E5%B9%B6%E5%8F%91--gmp%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Sat, 19 Oct 2024 07:58:46 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/027go%E5%B9%B6%E5%8F%91--gmp%E6%A8%A1%E5%9E%8B/</guid>
      <description>Go 语言的 GMP 调度模型 是 Go 语言并发的核心，它通过协程（Goroutine）的调度机制来实现高效并发。GMP 模型中，G 代表 Goroutine，M 代表操作系统线程（Machine），P 代表处理器（Processor）。这些组件共同作用，允许 Go 语言实现大规模的协程并发。&#xA;要理解 Go 的 GMP 调度模型，需要深入理解它如何协调 Goroutine、操作系统线程和处理器资源，使 Go 的并发操作既高效又能保持 Go 语言本身简洁的编程模型。&#xA;GMP 模型中的核心概念 Goroutine（G）&#xA;Goroutine 是 Go 语言的协程，Go 程序中的每一个并发任务都是一个 Goroutine。它比传统的线程更加轻量级，启动一个 Goroutine 的开销远小于创建一个操作系统线程。 每个 Goroutine 有一个自己的栈，初始时非常小（通常为 2KB），可以根据需要动态增长，避免了线程的高内存占用问题。 操作系统线程（M）&#xA;M 表示系统的内核线程。Go 的调度器使用操作系统线程来运行 Goroutine，多个 Goroutine 可能会在同一个 M 上运行，但一个 M 在任意时刻只能运行一个 Goroutine。 M 负责和操作系统的线程调度打交道，直接管理 CPU 资源。每个 M 都关联了一个 P 才能执行 Goroutine。 处理器（P）&#xA;P 是 Go 中的抽象概念，代表逻辑处理器。每个 P 维护一个本地的 Goroutine 队列，并负责调度这些 Goroutine。 P 的数量由环境变量 GOMAXPROCS 控制，表示可并行执行 Goroutine 的最大数量。 在任意时刻，只有一个 P 可以和 M 绑定，P 负责给绑定的 M 提供要执行的 Goroutine。 GMP 的调度原理 GMP 调度器的任务是将 Goroutine 高效地分配给系统中的线程执行，它的目标是使 Goroutine 在尽可能少的系统线程上运行，从而减少操作系统线程的创建和切换开销。GMP 的调度机制是协作式的，避免了频繁的系统调用。</description>
    </item>
    <item>
      <title>026Go基础-表格驱动测试</title>
      <link>https://ycchi0.github.io/posts/026go%E5%9F%BA%E7%A1%80-%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sat, 19 Oct 2024 03:49:17 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/026go%E5%9F%BA%E7%A1%80-%E8%A1%A8%E6%A0%BC%E9%A9%B1%E5%8A%A8%E6%B5%8B%E8%AF%95/</guid>
      <description>表格驱动测试（Table-Driven Testing）是 Go 语言中一种常用的单元测试模式，能够有效提高测试代码的可维护性和扩展性。它通过使用结构化的表格来组织测试用例，使得同一测试逻辑可以针对多组不同的输入输出进行测试。这种模式尤其适合测试具有多种输入场景的函数。&#xA;表格驱动测试的基本思想 表格驱动测试的核心思想是将测试数据以表格（通常是切片或数组）的形式组织起来，每行表格代表一个测试用例。每个测试用例包含输入数据和预期输出，随后通过循环遍历表格中的每一行来执行测试。&#xA;基本结构 表格驱动测试的典型结构如下：&#xA;定义一个包含多个测试用例的表格，通常用结构体数组来表示。 对每个测试用例，运行测试逻辑并检查输出是否与预期值匹配。 在测试失败时，输出详细的错误信息，方便调试。 一个简单的示例：&#xA;package main import ( &amp;#34;testing&amp;#34; ) // 被测试的函数 func add(a, b int) int { return a + b } // 表格驱动测试 func TestAdd(t *testing.T) { // 定义测试用例的表格 tests := []struct { name string // 测试用例的名称 inputA int // 输入 A inputB int // 输入 B expected int // 预期的输出 }{ {&amp;#34;1+1&amp;#34;, 1, 1, 2}, // 用例 1 {&amp;#34;2+3&amp;#34;, 2, 3, 5}, // 用例 2 {&amp;#34;-1+1&amp;#34;, -1, 1, 0}, // 用例 3 {&amp;#34;-1+-1&amp;#34;, -1, -1, -2}, // 用例 4 } // 遍历每一个测试用例 for _, tt := range tests { t.</description>
    </item>
    <item>
      <title>025Go基础-net/http/pprof </title>
      <link>https://ycchi0.github.io/posts/025.go%E5%9F%BA%E7%A1%80-net%E5%8C%85%E4%B8%8B%E7%9A%84pprof/</link>
      <pubDate>Sat, 19 Oct 2024 02:52:21 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/025.go%E5%9F%BA%E7%A1%80-net%E5%8C%85%E4%B8%8B%E7%9A%84pprof/</guid>
      <description>Go 语言中的 net/http/pprof 包为开发者提供了一个方便的接口，用于分析和调试 Go 应用程序的性能问题。该包集成了 Go 的性能剖析工具 pprof，并通过 HTTP 服务器暴露性能剖析接口。使用 net/http/pprof，开发者可以在应用程序运行时，收集 CPU 使用率、内存分配、阻塞情况以及 Goroutine 的信息，并生成相应的剖析报告，用于排查性能瓶颈。&#xA;net/http/pprof 的功能 net/http/pprof 提供了以下几个主要的性能剖析接口，通常通过 /debug/pprof 路径访问：&#xA;/debug/pprof/：提供一个简单的 HTML 页面，列出可用的剖析工具。 /debug/pprof/cmdline：显示程序启动的命令行参数。 /debug/pprof/profile：默认收集 30 秒的 CPU 剖析数据，下载一个 profile 文件，用于查看 CPU 使用情况。 /debug/pprof/symbol：显示程序的符号信息，帮助将剖析数据中的地址转化为可读的函数名。 /debug/pprof/trace：跟踪请求，记录请求执行过程中的详细信息。 /debug/pprof/goroutine：显示当前所有 Goroutine 的运行情况和堆栈跟踪。 /debug/pprof/heap：显示内存堆的使用情况，帮助分析内存分配。 /debug/pprof/threadcreate：显示线程创建的情况。 /debug/pprof/block：显示导致 Goroutine 阻塞的代码片段。 net/http/pprof 的基本用法 要在 Go 应用程序中启用 net/http/pprof，你只需要导入该包即可：&#xA;import _ &amp;#34;net/http/pprof&amp;#34; 这个导入语句会在默认的 HTTP 路由中自动注册 /debug/pprof 路径，无需进一步手动配置。&#xA;接下来，你需要启动一个 HTTP 服务器，以便可以通过浏览器或 curl 等工具访问这些剖析接口。通常可以在应用程序的调试模式或开发环境中添加以下代码：&#xA;package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; _ &amp;#34;net/http/pprof&amp;#34; // 引入 pprof 包 ) func main() { // 启动 HTTP 服务器并在 :6060 端口暴露 pprof 接口 log.</description>
    </item>
    <item>
      <title>024Go基础-性能测试</title>
      <link>https://ycchi0.github.io/posts/024go%E5%9F%BA%E7%A1%80-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Sat, 19 Oct 2024 02:27:40 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/024go%E5%9F%BA%E7%A1%80-%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description>Go 语言的性能测试（Benchmarking）是测试代码性能的重要工具，特别适用于测量代码的运行速度、资源消耗和执行效率。在 Go 中，性能测试可以通过 testing 包中的基准测试功能来进行。性能测试与单元测试类似，但它的目的是评估代码的性能，而不是验证代码的正确性。&#xA;基准测试概述 Go 的性能测试通过编写基准测试函数来进行，这些函数的名称必须以 Benchmark 开头，并接受一个 *testing.B 类型的参数。testing.B 是 Go 提供的专门用于基准测试的类型，它控制基准测试的迭代次数并提供记录执行时间的功能。&#xA;基准测试的基本格式如下：&#xA;package main import ( &amp;#34;testing&amp;#34; ) func BenchmarkExample(b *testing.B) { for i := 0; i &amp;lt; b.N; i++ { // 要进行性能测试的代码 } } 其中，b.N 是基准测试的核心部分，表示测试代码需要运行的次数。在每次运行时，Go 会自动调整 b.N 的值，确保测试得到准确的性能结果。&#xA;编写基准测试 假设我们要测试一个字符串拼接函数的性能：&#xA;package main import ( &amp;#34;strings&amp;#34; &amp;#34;testing&amp;#34; ) func BenchmarkStringConcat(b *testing.B) { for i := 0; i &amp;lt; b.N; i++ { _ = strings.Join([]string{&amp;#34;Hello&amp;#34;, &amp;#34;World&amp;#34;}, &amp;#34; &amp;#34;) } } 在这个基准测试中，strings.</description>
    </item>
    <item>
      <title>023Go基础-反射</title>
      <link>https://ycchi0.github.io/posts/023go%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 19 Oct 2024 02:26:33 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/023go%E5%9F%BA%E7%A1%80-%E5%8F%8D%E5%B0%84/</guid>
      <description>Go 语言中的反射（reflection）是一种强大的特性，它允许程序在运行时检查和操作自身的结构和类型信息。通过反射，开发者可以动态地获取变量的类型、修改变量的值、调用方法等。Go 语言的反射主要通过 reflect 包提供。&#xA;反射的基本概念 在 Go 语言中，反射的核心概念包括以下三个重要部分：&#xA;类型（Type）：即在运行时检查变量的类型。 值（Value）：即在运行时获取或修改变量的值。 类型信息（TypeOf）和值信息（ValueOf）：Go 语言中的 reflect 包提供了 TypeOf 和 ValueOf 函数，分别用于获取变量的类型和值。 下面我们通过示例逐步讲解反射在 Go 语言中的使用。&#xA;获取类型信息 在 Go 语言中，使用 reflect.TypeOf() 可以获取一个变量的类型。这个函数返回一个 reflect.Type 类型的值，表示变量的静态类型。&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { var x int = 42 t := reflect.TypeOf(x) fmt.Println(&amp;#34;Type:&amp;#34;, t) } 输出结果：&#xA;Type: int 获取值信息 使用 reflect.ValueOf() 可以获取一个变量的值。reflect.ValueOf() 返回 reflect.Value 类型的值，代表变量在运行时的具体值。&#xA;func main() { var x int = 42 v := reflect.</description>
    </item>
    <item>
      <title>022.Go基础-可变参数</title>
      <link>https://ycchi0.github.io/posts/022.go%E5%9F%BA%E7%A1%80-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</link>
      <pubDate>Sat, 19 Oct 2024 02:16:06 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/022.go%E5%9F%BA%E7%A1%80-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/</guid>
      <description>在 Go 语言中，变参（可变参数）允许函数接收任意数量的参数。这种机制非常有用，可以在函数定义时不确定传入参数的数量。变参在 Go 语言中通过 ... 语法来实现。具体地，变参会被当作一个切片传递给函数。&#xA;变参的基本用法 在 Go 中定义一个变参函数时，可以将参数类型前加上 ... 表示该函数可以接收任意多个这种类型的参数。例如：&#xA;func sum(nums ...int) int { total := 0 for _, num := range nums { total += num } return total } func main() { result := sum(1, 2, 3, 4, 5) fmt.Println(result) // 输出 15 } 在上面的例子中，sum 函数接收多个 int 类型的参数，这些参数在函数内部以切片的形式出现，即 nums []int，可以通过循环遍历来进行操作。&#xA;变参的底层原理 变参实际上会被 Go 语言编译器转换为切片。在函数内部，你可以把变参当作一个切片来使用。这也是为什么在循环或调用切片函数时可以直接操作变参的原因。&#xA;例如，在上述的 sum 函数中，nums 是一个切片（[]int），我们可以像操作普通的切片一样对它进行操作。&#xA;使用变参传递现有的切片 如果你已经有了一个切片，并希望将其作为变参传递给函数，可以使用 slice... 的语法。这表示将切片的所有元素打散，作为独立的参数传递给函数。&#xA;func main() { nums := []int{1, 2, 3, 4, 5} result := sum(nums.</description>
    </item>
    <item>
      <title>021.Go基础 系统包</title>
      <link>https://ycchi0.github.io/posts/021.go%E5%9F%BA%E7%A1%80-%E7%B3%BB%E7%BB%9F%E5%8C%85/</link>
      <pubDate>Sat, 19 Oct 2024 00:50:41 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/021.go%E5%9F%BA%E7%A1%80-%E7%B3%BB%E7%BB%9F%E5%8C%85/</guid>
      <description>在 Go 语言中，系统包（或标准库）是指 Go 自带的一组库，它们为开发者提供了常见功能的实现，而无需引入第三方依赖。这些包涵盖了多种功能，比如输入输出、文件操作、网络编程、并发处理、加密、字符串处理等。Go 语言的系统包以其简洁、高效以及与 Go 语言本身设计哲学的一致性而著称。下面简要介绍几个常用的系统包：&#xA;1. fmt 包 fmt 是 Go 语言中用于格式化输入输出的包。通过这个包，开发者可以轻松地打印、格式化输出和获取输入。常用的函数包括：&#xA;fmt.Println()：打印并换行。 fmt.Printf()：格式化打印输出。 fmt.Scan() 和 fmt.Scanf()：从标准输入读取数据。 fmt.Println(&amp;#34;Hello, Go!&amp;#34;) fmt.Printf(&amp;#34;The number is: %d\n&amp;#34;, 42) 2. os 包 os 包提供了与操作系统交互的功能，比如文件和目录的操作、环境变量的访问等。常用的函数包括：&#xA;os.Open()：打开文件。 os.Create()：创建文件。 os.Remove()：删除文件。 os.Getenv()：获取环境变量。 file, err := os.Open(&amp;#34;file.txt&amp;#34;) if err != nil { fmt.Println(err) } defer file.Close() env := os.Getenv(&amp;#34;PATH&amp;#34;) fmt.Println(&amp;#34;PATH:&amp;#34;, env) 3. net/http 包 net/http 是用于处理 HTTP 请求和响应的包。它广泛应用于构建 Web 服务或进行 HTTP 客户端操作。常用的功能包括：&#xA;http.Get()：发送 HTTP GET 请求。 http.Post()：发送 HTTP POST 请求。 http.</description>
    </item>
    <item>
      <title>020.Go基础-并发编程</title>
      <link>https://ycchi0.github.io/posts/020.go%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</link>
      <pubDate>Fri, 18 Oct 2024 02:42:03 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/020.go%E5%9F%BA%E7%A1%80-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/</guid>
      <description>Go 语言中的并发是其核心功能之一，它通过轻量级的 goroutine 和强大的通信机制（通道，channels）来支持高效的并发编程。Go 以简洁和高效的方式处理并发，而不是像传统语言那样依赖操作系统级线程。Go 的并发模型受到 CSP（Communicating Sequential Processes）模型的启发，注重通过消息传递来实现不同线程之间的协作。&#xA;1. Goroutines（协程） Goroutine 是 Go 语言的并发执行单元。它类似于线程，但比线程更轻量。Go 的运行时会自动调度 goroutine，而不是依赖操作系统线程调度。一个 Go 程序可以同时运行成千上万个 goroutine，这得益于它的低开销。&#xA;语法：只需要在函数调用前加上 go 关键字即可启动一个新的 goroutine。&#xA;示例：&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func say(s string) { for i := 0; i &amp;lt; 5; i++ { fmt.Println(s) time.Sleep(100 * time.Millisecond) } } func main() { go say(&amp;#34;Hello&amp;#34;) // 启动一个新的 goroutine say(&amp;#34;World&amp;#34;) // 在主 goroutine 中运行 } 在这个例子中，say(&amp;quot;Hello&amp;quot;) 和 say(&amp;quot;World&amp;quot;) 运行在不同的 goroutine 中。这展示了 Go 的并发特性。</description>
    </item>
    <item>
      <title>019.Go基础-错误处理</title>
      <link>https://ycchi0.github.io/posts/019.go%E5%9F%BA%E7%A1%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Fri, 18 Oct 2024 02:32:30 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/019.go%E5%9F%BA%E7%A1%80-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>在 Go 语言中，错误处理是通过显式返回错误值来实现的，而不是依赖像其他语言（如 Java、Python）中的异常机制。这种设计强调了错误处理的明确性和简洁性，使开发者在编写代码时可以更清晰地处理可能发生的错误。&#xA;1. Go 中的错误处理机制 Go 使用内置的 error 类型来表示错误。error 是一个接口，定义如下：&#xA;type error interface { Error() string } 任何实现了 Error() 方法的类型都可以作为错误类型。通常，Go 的函数会返回两个值：一个是正常的返回值，另一个是表示错误的 error。如果没有错误发生，error 通常会返回 nil。&#xA;示例：&#xA;package main import ( &amp;#34;errors&amp;#34; &amp;#34;fmt&amp;#34; ) // 定义一个简单的函数，返回一个错误 func divide(a, b int) (int, error) { if b == 0 { return 0, errors.New(&amp;#34;cannot divide by zero&amp;#34;) } return a / b, nil } func main() { result, err := divide(4, 2) if err !</description>
    </item>
    <item>
      <title>017.Go基础-nil</title>
      <link>https://ycchi0.github.io/posts/017.go%E5%9F%BA%E7%A1%80-nil/</link>
      <pubDate>Fri, 18 Oct 2024 01:37:32 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/017.go%E5%9F%BA%E7%A1%80-nil/</guid>
      <description>在 Go 语言中，nil 是一个特殊的标识符，用来表示变量没有值或空值。nil 类似于其他编程语言中的 null 或 None，但它在 Go 中具有特定的应用场景。nil 可以用于多个类型，包括指针、接口、切片、映射、通道、函数等。&#xA;1. nil 的用途 Go 语言中的 nil 可用于以下几种类型：&#xA;指针：表示指针不指向任何内存地址。 接口：表示接口的动态类型和值为空。 切片：表示切片不引用底层数组。 映射：表示映射未被初始化。 通道：表示通道未被初始化。 函数：表示函数变量未被赋值。 2. nil 的使用场景 2.1 指针与 nil 在 Go 中，指针是一种保存变量内存地址的类型，nil 可以表示指针不指向任何有效的内存地址。&#xA;示例：&#xA;package main import &amp;#34;fmt&amp;#34; func main() { var p *int = nil // 定义一个 nil 指针 fmt.Println(p) // 输出：&amp;lt;nil&amp;gt; var x int = 10 p = &amp;amp;x // 将 p 指向变量 x fmt.Println(p) // 输出：x 的地址 fmt.</description>
    </item>
    <item>
      <title>016.Go基础-类型的内嵌</title>
      <link>https://ycchi0.github.io/posts/016.go%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%B5%8C/</link>
      <pubDate>Fri, 18 Oct 2024 01:35:38 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/016.go%E5%9F%BA%E7%A1%80-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%86%85%E5%B5%8C/</guid>
      <description>Go 语言中的**类型内嵌（Type Embedding）是实现代码复用和简化类型设计的重要特性之一，它允许一个结构体或接口将另一个类型嵌入到自身中，而不需要通过显式继承来实现。内嵌类似于面向对象语言中的“继承”机制，但更灵活和简洁。通过类型内嵌，Go 实现了组合（Composition）**这一设计模式，提供了高效的代码复用方式。&#xA;1. 结构体的内嵌 结构体可以直接嵌入另一个结构体，从而使得嵌入的类型的字段和方法可以直接在外层结构体中使用，而不需要显式引用嵌入的类型。这类似于传统的“继承”，但更加简化。&#xA;结构体内嵌示例：&#xA;package main import &amp;#34;fmt&amp;#34; // 定义一个基础结构体 type Animal struct { Name string } // 为 Animal 结构体定义方法 func (a Animal) Speak() { fmt.Println(a.Name, &amp;#34;makes a sound&amp;#34;) } // 定义一个新结构体，将 Animal 内嵌 type Dog struct { Animal // 内嵌 Animal 结构体 Breed string } func main() { d := Dog{ Animal: Animal{Name: &amp;#34;Rex&amp;#34;}, // 初始化内嵌的 Animal 类型 Breed: &amp;#34;Labrador&amp;#34;, } // 直接访问内嵌的 Animal 结构体的字段和方法 fmt.</description>
    </item>
    <item>
      <title>015.Go基础-面向对象</title>
      <link>https://ycchi0.github.io/posts/015.go%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Fri, 18 Oct 2024 01:20:40 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/015.go%E5%9F%BA%E7%A1%80-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>Go 语言虽然不完全符合传统的面向对象编程（OOP）模型，但它具有一些关键的 OOP 特性，例如封装、组合和多态，这些可以通过 Go 的**结构体（struct）和接口（interface）**来实现。&#xA;在 Go 语言中，面向对象的概念不是通过继承和类来实现，而是通过组合与接口设计来模拟和实现多态性和扩展性。&#xA;1. Go 语言的结构（struct） Go 中的结构体（struct）类似于其他语言中的类，但没有继承关系。struct 是一种聚合数据类型，用于将多个字段组织在一起。与类不同的是，Go 没有构造函数或析构函数的概念，也没有隐式的继承。&#xA;定义结构体：&#xA;type Person struct { Name string Age int } 使用结构体：&#xA;func main() { p := Person{Name: &amp;#34;Alice&amp;#34;, Age: 25} fmt.Println(p.Name) // 输出：Alice fmt.Println(p.Age) // 输出：25 } 为结构体定义方法 Go 中的方法是绑定到类型（包括结构体）的。方法的接收者可以是值类型或指针类型，这取决于你想在方法中修改结构体还是只读取它的内容。&#xA;type Person struct { Name string Age int } // 为结构体定义方法 func (p Person) Greet() { fmt.Println(&amp;#34;Hello, my name is&amp;#34;, p.Name) } func main() { p := Person{Name: &amp;#34;Alice&amp;#34;, Age: 25} p.</description>
    </item>
    <item>
      <title>014.Go基础-扩展类型</title>
      <link>https://ycchi0.github.io/posts/014.go%E5%9F%BA%E7%A1%80-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Fri, 18 Oct 2024 01:15:07 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/014.go%E5%9F%BA%E7%A1%80-%E6%89%A9%E5%B1%95%E7%B1%BB%E5%9E%8B/</guid>
      <description>在 Go 语言中，拓展已有类型的方式主要有两种：创建类型别名和定义新类型。通过这两种方式，你可以为已有类型添加新的行为或定义，尤其是在不想修改原有类型的情况下。下面分别解释这两种方式。&#xA;1. 类型别名（Type Alias） 类型别名用于为现有类型创建一个新的名称。这实际上不会创建新的类型，只是为原有类型提供了一个新的名字。&#xA;语法：&#xA;type NewType = ExistingType 示例：&#xA;package main import ( &amp;#34;fmt&amp;#34; ) type MyInt = int // MyInt 是 int 的别名 func main() { var a MyInt = 100 fmt.Println(a) // 输出：100 } 特点：&#xA;别名类型和原始类型完全相同，可以相互赋值。 别名主要用于代码重构或增加代码可读性。 2. 定义新类型（Type Declaration） 通过定义新类型，你可以基于已有类型创建一个新的类型，并为这个新类型添加方法。新类型和原始类型在 Go 中被视为不同的类型，即使它们底层的表示相同。&#xA;语法：&#xA;type NewType ExistingType 示例：&#xA;package main import ( &amp;#34;fmt&amp;#34; ) type MyInt int // 基于 int 定义了新类型 MyInt // 为 MyInt 类型定义一个方法 func (m MyInt) Print() { fmt.</description>
    </item>
    <item>
      <title>013.Go基础 Range</title>
      <link>https://ycchi0.github.io/posts/013.go%E5%9F%BA%E7%A1%80-range/</link>
      <pubDate>Wed, 16 Oct 2024 12:56:40 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/013.go%E5%9F%BA%E7%A1%80-range/</guid>
      <description>在 Go 语言中，range 是一个用于遍历各种数据结构的关键字，包括数组、切片、字符串、map 和通道。它提供了一种简洁、通用的方式来访问集合中的元素。&#xA;1. range 用于数组和切片 当 range 用于 数组 或 切片 时，它返回两个值：索引 和 元素的副本。&#xA;示例：range 遍历数组或切片 arr := []int{10, 20, 30, 40} for i, v := range arr { fmt.Printf(&amp;#34;索引: %d, 值: %d\n&amp;#34;, i, v) } 输出：&#xA;索引: 0, 值: 10 索引: 1, 值: 20 索引: 2, 值: 30 索引: 3, 值: 40 i 是索引 v 是该索引处元素的副本 只需要元素或索引时 如果只需要索引或值，可以使用 下划线_ 忽略不需要的值。&#xA;只需要索引： for i := range arr { fmt.</description>
    </item>
    <item>
      <title>012.Go基础 Map</title>
      <link>https://ycchi0.github.io/posts/012.go%E5%9F%BA%E7%A1%80-map/</link>
      <pubDate>Wed, 16 Oct 2024 12:56:21 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/012.go%E5%9F%BA%E7%A1%80-map/</guid>
      <description>在 Go 语言中，map是一种内置的数据结构，用于存储键值对（key-value pairs）。它非常类似于其他编程语言中的哈希表（hash table）或字典（dictionary）。Go 语言中的map提供了高效的键值查找、插入和删除操作，是处理关联数据的首选结构。&#xA;1. map 的定义和初始化 map的定义方式为map[keyType]valueType，其中keyType表示键的类型，valueType表示值的类型。&#xA;示例：定义一个map var m map[string]int // 声明一个key为string，value为int的map 在 Go 中，map的零值是nil，如果没有进行初始化就直接操作map，会导致运行时错误。因此，使用map之前必须先进行初始化。&#xA;1.1 使用 make 初始化 map Go 提供了内置的make函数来初始化map。&#xA;m := make(map[string]int) // 使用make函数创建一个map m[&amp;#34;apple&amp;#34;] = 5 m[&amp;#34;banana&amp;#34;] = 10 fmt.Println(m) // 输出 map[apple:5 banana:10] 在这个例子中，我们使用make函数初始化了一个map，并通过键值对的方式插入了两个元素。&#xA;1.2 使用字面量创建和初始化 map 除了使用make函数，map还可以通过字面量直接创建并初始化。&#xA;m := map[string]int{ &amp;#34;apple&amp;#34;: 5, &amp;#34;banana&amp;#34;: 10, } fmt.Println(m) // 输出 map[apple:5 banana:10] 这种方式不仅简洁，而且可以在声明时同时进行赋值。&#xA;2. map 的基本操作 2.1 插入元素 在map中插入元素的方式非常简单，直接通过map[key] = value的形式即可。&#xA;m := make(map[string]int) m[&amp;#34;orange&amp;#34;] = 20 // 插入键&amp;#34;orange&amp;#34;对应的值为20 2.</description>
    </item>
    <item>
      <title>011.Go基础 切片</title>
      <link>https://ycchi0.github.io/posts/011.go%E5%9F%BA%E7%A1%80-%E5%88%87%E7%89%87/</link>
      <pubDate>Wed, 16 Oct 2024 12:55:56 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/011.go%E5%9F%BA%E7%A1%80-%E5%88%87%E7%89%87/</guid>
      <description>在 Go 语言中，切片（slice） 是一种非常重要的数据结构，它是对数组的抽象，是一个动态大小的序列。与数组不同，切片的长度是可以变化的，因而更灵活、更常用。切片本质上是对底层数组的引用，允许我们在不复制数据的情况下处理数组的某一部分。&#xA;1. 切片的定义与创建 切片由三部分组成：指针（指向底层数组的某个元素）、长度（当前切片中包含的元素数）和容量（从切片的起始位置到底层数组末尾的元素数）。&#xA;创建切片的方式有几种常见的方式： 1.1 使用现有数组创建切片 通过数组生成切片，可以通过array[start:end]的方式从数组中创建切片，切片不包含end位置的元素。&#xA;arr := [5]int{1, 2, 3, 4, 5} slice := arr[1:4] // 从数组创建切片，包含索引1到索引3的元素 fmt.Println(slice) // 输出 [2 3 4] 1.2 使用make()函数创建切片 make函数是 Go 语言中用于创建切片、映射（map）和通道（channel）的内置函数。通过make函数创建切片时，可以指定切片的长度和容量。&#xA;slice := make([]int, 3, 5) // 创建长度为3，容量为5的切片 fmt.Println(slice) // 输出 [0 0 0] 在这个例子中，切片slice的长度是3，容量是5，所有元素初始化为0。&#xA;1.3 使用切片字面量创建切片 可以像数组一样使用字面量创建切片。不同的是，切片不需要指定长度，长度由初始值的个数决定。&#xA;slice := []int{1, 2, 3, 4} fmt.Println(slice) // 输出 [1 2 3 4] 2. 切片的长度和容量 长度：切片中的元素个数，通过len()函数可以获取切片的长度。 容量：切片从起始位置到底层数组末尾的元素数，通过cap()函数可以获取切片的容量。 示例：查看切片的长度和容量 slice := []int{1, 2, 3, 4, 5} fmt.</description>
    </item>
    <item>
      <title>010.Go基础 数组</title>
      <link>https://ycchi0.github.io/posts/010.go%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84/</link>
      <pubDate>Wed, 16 Oct 2024 12:55:16 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/010.go%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84/</guid>
      <description>在 Go 语言中，数组是一种固定长度、同构（同一类型）的数据集合。数组可以存储同一类型的数据元素，并且数组的长度在声明时就被确定，不能动态改变。Go 语言的数组有明确的类型和长度，因此与一些动态语言中的数组不同，Go 的数组在使用时需要考虑其长度和类型。&#xA;1. 数组的定义 在 Go 语言中，数组通过方括号[]定义，方括号中的数字表示数组的长度，之后跟随数组中元素的类型。数组的长度是数组类型的一部分，因此长度不同的数组是不同的类型。&#xA;示例：数组的定义和初始化 var arr [5]int // 声明一个长度为5的int类型数组，元素默认值为0 fmt.Println(arr) // 输出 [0 0 0 0 0] 在这个例子中，声明了一个int类型的数组arr，它有 5 个元素，每个元素的初始值为0（因为 Go 中的整数类型默认值是0）。&#xA;2. 数组的初始化 数组在声明的同时可以进行初始化。可以使用字面量的方式为数组赋值，或者只初始化部分元素，剩下的元素会使用该类型的零值进行填充。&#xA;示例：数组的初始化 arr1 := [5]int{1, 2, 3, 4, 5} // 初始化一个长度为5的数组 fmt.Println(arr1) // 输出 [1 2 3 4 5] arr2 := [5]int{1, 2} // 部分初始化，剩余元素自动赋值为0 fmt.Println(arr2) // 输出 [1 2 0 0 0] 可以通过这种方式只初始化数组的一部分，未初始化的元素会自动设为该类型的默认值。&#xA;3. 使用自动推断长度的数组 在数组初始化时，可以省略数组的长度，Go 会根据提供的初始值个数自动推断数组的长度。&#xA;示例：自动推断数组长度 arr := [.</description>
    </item>
    <item>
      <title>009.Go基础 指针</title>
      <link>https://ycchi0.github.io/posts/009.go%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/</link>
      <pubDate>Wed, 16 Oct 2024 12:54:55 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/009.go%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/</guid>
      <description>在 Go 语言中，指针是指向变量内存地址的变量。指针可以用来直接操作内存，并且可以通过指针共享数据，避免不必要的拷贝。在 Go 中，虽然没有像 C 语言那样的指针运算，但 Go 提供了简单且安全的指针功能，使开发者可以在安全的环境下进行内存操作。&#xA;1. 指针的基本概念 指针是保存内存地址的变量。通过指针，我们可以间接地访问或修改变量的值。&#xA;示例：指针的基本使用 var x int = 42 var p *int = &amp;amp;x // 获取变量x的地址，并将其赋值给指针p fmt.Println(p) // 输出内存地址，例如：0xc0000140b0 fmt.Println(*p) // 输出指针p指向的值，即42 在这个例子中：&#xA;&amp;amp;x 是取变量x的地址，返回一个指向x的指针。 *p 是解引用操作，通过指针p访问其指向的变量的值。 2. 指针类型 Go 语言中的每种类型都有其对应的指针类型。例如：&#xA;int类型的指针是*int float64类型的指针是*float64 自定义类型的指针也是类似的。 示例：不同类型的指针 var a int = 10 var b float64 = 25.5 var c string = &amp;#34;hello&amp;#34; var pA *int = &amp;amp;a var pB *float64 = &amp;amp;b var pC *string = &amp;amp;c fmt.</description>
    </item>
    <item>
      <title>008.Go基础 函数</title>
      <link>https://ycchi0.github.io/posts/008.go%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 16 Oct 2024 12:54:38 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/008.go%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/</guid>
      <description>在 Go 语言中，函数是程序的基本构建块之一。函数定义了可复用的代码块，通过传递参数和返回值来实现逻辑封装。Go 语言的函数具有灵活和强大的特性，如支持多返回值、匿名函数、闭包以及延迟执行（defer）等。接下来，我将介绍 Go 语言中的函数特性及其使用方式。&#xA;1. 基本函数定义 Go 语言中，函数的定义使用关键字func，并且参数和返回值的类型必须显式声明。&#xA;func 函数名(参数列表) 返回值类型 { // 函数体 } 示例：基本函数 func add(x int, y int) int { return x + y } func main() { result := add(3, 4) fmt.Println(result) // 输出 7 } 在这个示例中，add函数接受两个int类型的参数，并返回它们的和。&#xA;2. 多返回值函数 Go 语言允许函数返回多个值。这在需要返回结果和错误状态的情况下特别有用。&#xA;示例：多返回值 func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(&amp;#34;hello&amp;#34;, &amp;#34;world&amp;#34;) fmt.Println(a, b) // 输出 world hello } 在这个示例中，swap函数返回两个字符串，通过多重赋值操作接收返回值。</description>
    </item>
    <item>
      <title>007.Go基础 Chan</title>
      <link>https://ycchi0.github.io/posts/007.go%E5%9F%BA%E7%A1%80-chan/</link>
      <pubDate>Wed, 16 Oct 2024 12:54:16 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/007.go%E5%9F%BA%E7%A1%80-chan/</guid>
      <description>在 Go 语言中，chan（通道）是一种用于在多个 Goroutine 之间传递数据的机制。Go 语言通过 Goroutines 实现并发，而通道（Channel）是这些 Goroutines 之间进行通信的工具。通道可以发送和接收数据，帮助程序在并发场景下保持数据的一致性和同步性。&#xA;通道的定义与基本用法 通道在 Go 中是一个类型化的管道，声明时需要指定通道传输的数据类型。你可以创建一个传输不同类型数据的通道，比如传输整数、字符串或结构体。&#xA;1. 通道的声明和初始化 使用make函数来创建通道：&#xA;ch := make(chan int) // 创建一个传输int类型数据的通道 2. 发送和接收数据 发送数据到通道：使用&amp;lt;-符号将数据发送到通道。 从通道接收数据：使用&amp;lt;-符号从通道接收数据。 ch := make(chan int) // 向通道发送数据 go func() { ch &amp;lt;- 42 }() // 从通道接收数据 value := &amp;lt;-ch fmt.Println(value) // 输出 42 在上面的示例中，go func()是一个 Goroutine，运行在一个独立的线程中。它将42发送到通道ch中，主 Goroutine 则从通道中接收该值并打印。&#xA;通道的同步特性 通道不仅仅用于传递数据，它还可以作为一种同步机制。当一个 Goroutine 尝试向通道发送数据时，除非另一个 Goroutine 正在从该通道接收数据，否则它会被阻塞。同样，接收操作会阻塞，直到有数据从通道发送过来。因此，通道可以用来确保多个 Goroutine 之间的操作同步。&#xA;示例：同步两个 Goroutine ch := make(chan bool) go func() { fmt.</description>
    </item>
    <item>
      <title>006.Go基础 循环语句</title>
      <link>https://ycchi0.github.io/posts/006.go%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Wed, 16 Oct 2024 12:53:56 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/006.go%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</guid>
      <description>在 Go 语言中，循环语句主要通过for关键字实现。Go 语言不像其他一些编程语言（如 C、Java）有while和do-while循环，for是唯一的循环结构，但它非常灵活，可以实现多种类型的循环。以下是 Go 语言中几种常见的循环用法：&#xA;1. 标准的for循环 这种for循环和 C 语言、Java 中的for循环类似，包含三个部分：初始化语句、条件表达式和后置语句。&#xA;for i := 0; i &amp;lt; 10; i++ { fmt.Println(i) } 初始化语句：在循环开始时执行一次（i := 0）。 条件表达式：每次循环前都会判断，条件为true时继续执行循环（i &amp;lt; 10）。 后置语句：每次循环结束后执行（i++）。 2. 类似while的循环 如果省略初始化语句和后置语句，for循环可以用来模拟while循环：&#xA;i := 0 for i &amp;lt; 10 { fmt.Println(i) i++ } 这种形式的for循环类似于其他语言中的while循环，在条件为true时持续执行。&#xA;3. 无限循环 如果for的条件表达式也被省略，那么就变成了一个无限循环：&#xA;for { fmt.Println(&amp;#34;无限循环&amp;#34;) } 这种循环通常与break或return配合使用，用于在特定条件下退出循环。&#xA;4. range 关键字遍历集合 Go 语言的for循环还可以结合range关键字用于遍历数组、切片、映射和字符串：&#xA;// 遍历数组 arr := []int{1, 2, 3, 4} for index, value := range arr { fmt.</description>
    </item>
    <item>
      <title>005.Go基础 分支语句</title>
      <link>https://ycchi0.github.io/posts/005.go%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</link>
      <pubDate>Wed, 16 Oct 2024 12:53:27 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/005.go%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/</guid>
      <description>Go 语言中的分支结构用于根据条件执行不同的代码路径。常见的分支结构有 if 语句、switch 语句和特殊的 select 语句。每种分支结构都有其适用场景，下面我将详细介绍它们。&#xA;1. if 语句 if 语句是最常用的条件分支结构，依据一个布尔表达式的结果来决定是否执行某段代码。Go 语言的 if 语句语法简单，且支持可选的初始化语句。&#xA;语法： if condition { // 当 condition 为 true 时执行 } 示例：基本 if 语句 package main import &amp;#34;fmt&amp;#34; func main() { x := 10 if x &amp;gt; 5 { fmt.Println(&amp;#34;x 大于 5&amp;#34;) } } 示例：带初始化语句的 if Go 语言的 if 语句支持在条件判断前执行一个短语句，这个特性通常用于声明和初始化局部变量。&#xA;if x := 10; x &amp;gt; 5 { fmt.Println(&amp;#34;x 大于 5&amp;#34;) } x 只在 if 语句的作用域内可见。 if-else 语句 if condition { // 当 condition 为 true 时执行 } else { // 当 condition 为 false 时执行 } 示例：if-else 语句 x := 3 if x &amp;gt; 5 { fmt.</description>
    </item>
    <item>
      <title>004.GO基础 运算符</title>
      <link>https://ycchi0.github.io/posts/004.go%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/</link>
      <pubDate>Wed, 16 Oct 2024 12:52:59 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/004.go%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/</guid>
      <description>Go 语言的运算符主要分为以下几大类：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。每类运算符都用于特定的操作，帮助程序完成各种计算和逻辑判断。下面是详细介绍：&#xA;1. 算术运算符（Arithmetic Operators） 算术运算符用于执行基本的数学运算。&#xA;运算符 描述 示例 结果 + 加法 5 + 3 8 - 减法 5 - 3 2 * 乘法 5 * 3 15 / 除法 5 / 2 2（整除） % 取余 5 % 2 1 ++ 自增 a++ 等同于 a = a + 1 -- 自减 a-- 等同于 a = a - 1 注意：&#xA;++ 和 -- 是 后缀运算符，即先返回当前值，再自增或自减。 整数除法会丢弃小数部分，例如 5 / 2 的结果为 2，而不是 2.</description>
    </item>
    <item>
      <title>003.Go基础 代替枚举的方法</title>
      <link>https://ycchi0.github.io/posts/003.go%E5%9F%BA%E7%A1%80-%E4%BB%A3%E6%9B%BF%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 16 Oct 2024 12:52:05 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/003.go%E5%9F%BA%E7%A1%80-%E4%BB%A3%E6%9B%BF%E6%9E%9A%E4%B8%BE%E7%9A%84%E6%96%B9%E6%B3%95/</guid>
      <description>Go 语言没有直接提供枚举（enum）关键字或专门的枚举类型。不过，Go 使用常量（const）和类型别名结合其他特性，提供了一种有效的枚举替代方式。这种方式既保持了 Go 语言的简洁性，也能够达到枚举的功能。&#xA;1. 使用 const 和 iota Go 中常见的枚举替代方法是使用 const 和 iota。iota 是一个特殊的标识符，它在 const 块中自动递增，常用于定义一系列相关常量。&#xA;示例：简单的枚举 package main import &amp;#34;fmt&amp;#34; const ( Red = iota // 0 Green // 1 Blue // 2 ) func main() { fmt.Println(Red, Green, Blue) // 输出：0 1 2 } iota 从 0 开始，每声明一个常量，它的值会自动递增。因此，在上面的例子中，Red、Green 和 Blue 分别对应 0、1 和 2。 2. 定义类型别名来增强枚举的类型安全性 为了增强类型安全性并使枚举更具可读性，通常会为这些常量定义一个自定义的类型别名。这样可以限制变量只能取该类型中的值，类似于传统编程语言中的枚举类型。&#xA;示例：带类型的枚举 package main import &amp;#34;fmt&amp;#34; // 定义一个自定义类型 type Color int // 使用 iota 定义枚举值 const ( Red Color = iota Green Blue ) func main() { var c Color = Green fmt.</description>
    </item>
    <item>
      <title>002.Go基础 基础数据类型</title>
      <link>https://ycchi0.github.io/posts/002.go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Wed, 16 Oct 2024 12:51:43 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/002.go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Go 语言是一种静态强类型语言，提供了多种基础数据类型，主要分为 布尔型、数字型、字符串型 和 特殊类型（byte 和 rune），此外还有一些常用的复合类型。以下是详细介绍：&#xA;1. 布尔型（Boolean） 类型： bool 取值： true 或 false 示例： var isTrue bool = true var isFalse bool = false 2. 数字类型（Numeric Types） 数字类型分为 整数类型、浮点数类型 和 复数类型。&#xA;2.1. 整数类型（Integer Types） 有符号整数： 类型： int8, int16, int32, int64 范围： int8: -128 到 127 int16: -32,768 到 32,767 int32: -2,147,483,648 到 2,147,483,647 int64: -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 示例： var a int8 = -100 var b int32 = 10000 无符号整数： 类型： uint8, uint16, uint32, uint64 范围： uint8: 0 到 255 uint16: 0 到 65,535 uint32: 0 到 4,294,967,295 uint64: 0 到 18,446,744,073,709,551,615 示例： var c uint8 = 200 var d uint32 = 40000 机器字长整数： 类型： int, uint 范围： 取决于系统架构（32 位或 64 位）。 示例： var e int = -50 var f uint = 50 2.</description>
    </item>
    <item>
      <title>001.Go基础 变量与常量</title>
      <link>https://ycchi0.github.io/posts/001.go%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</link>
      <pubDate>Wed, 16 Oct 2024 12:49:46 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/001.go%E5%9F%BA%E7%A1%80-%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/</guid>
      <description>在 Go 语言中，变量和常量是两种不同的存储和管理数据的方式。&#xA;它们有各自的特点和用途。我们来分别讨论：&#xA;1. 变量（Variables） 声明和使用： 变量是可以改变值的存储单元。你可以在程序运行过程中多次赋值修改它的值。 Go 语言通过关键字 var 声明变量。也可以使用简短的 := 语法来声明和初始化变量。 var x int = 10 // 声明变量并赋初始值 y := 20 // 使用简短声明，类型推断为 int 特点： 类型系统：Go 是静态类型语言，变量声明时可以指定类型。如果不指定类型，编译器会根据初始化的值推断类型。 默认值：如果声明变量时没有赋值，Go 会赋予该变量一个“零值”。例如，整数类型的零值是 0，布尔类型的零值是 false。 var z int // z 的值为 0，默认值 可变性：变量的值是可以更改的。例如，你可以多次对一个变量进行赋值： x = 15 // 重新赋值 多变量声明： Go 支持同时声明多个变量：&#xA;var a, b, c int = 1, 2, 3 2. 常量（Constants） 声明和使用： 常量是程序运行期间不可改变的值。它们在定义时必须赋值，并且赋值后不能再修改。 常量通过 const 关键字声明。 const Pi float64 = 3.</description>
    </item>
    <item>
      <title>ETCD应用场景</title>
      <link>https://ycchi0.github.io/posts/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link>
      <pubDate>Thu, 30 May 2024 17:37:32 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/etcd%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid>
      <description>前置知识 ETCD的租约机制 租约是ETCD中的一种抽象，它可以关联到一个或多个键值对，当租约过期时，与其关联的所有键值对都会被自动删除。&#xA;以下是ETCD租约机制的主要特性和使用方式：&#xA;创建租约：客户端可以通过调用ETCD的API创建一个新的租约。创建租约时需要指定一个TTL（Time To Live），表示租约的有效期。创建成功后，ETCD会返回一个唯一的租约ID。&#xA;关联键值对：客户端在创建或修改键值对时，可以指定一个租约ID，将键值对关联到这个租约。这样，当租约过期时，这个键值对会被自动删除。&#xA;续租：客户端可以通过调用ETCD的API来续租一个租约，即重新设置租约的TTL。这样可以防止租约过期，与其关联的键值对被删除。&#xA;撤销租约：客户端可以通过调用ETCD的API来撤销一个租约。撤销租约会导致与其关联的所有键值对被立即删除。&#xA;租约超时：如果客户端在租约的TTL时间内没有进行续租操作，那么租约会自动过期，与其关联的所有键值对都会被ETCD自动删除。&#xA;一个租约可以挂多个key，一个key只能挂一个租约&#xA;应用场景 服务发现 服务注册与发现(Service Discovery)是ETCD最常见的使用场景，解决的是如何在同一个分布式集群中的进程或服务找到目标服务的IP地址并建立连接。&#xA;在分布式系统中，服务提供者都是以集群的方式对外提供服务，集群中服务的IP随时都可能发生变化，因此服务提供者需要将自己的服务注册到ETCD中去。这样，服务使用者通过ETCD可以获取到实际服务提供者的ip信息，连接到服务提供者，进行后续操作。&#xA;消息发布与订阅 使用ETCD进行消息发布与订阅，实际上就是构建一个配置共享中心&#xA;消息发布方在将消息存储到对应的key上，消息订阅者在ETCD节点上注册一个Watcher并等待，以后每次配置有更新的适合，ETCD都会实时通知订阅者，以此达到获取最新配置信息的目的。&#xA;分布式锁 ETCD实现分布式锁的关键在于其Compare-and-Swap（CAS）操作和TTL（Time To Live）特性。&#xA;以下是ETCD实现分布式锁的详细步骤：&#xA;获取锁：客户端尝试获取锁，通过调用ETCD的CAS操作。在这个操作中，客户端会尝试创建一个键值对，键是锁的名称，值是一个唯一标识（例如，客户端的ID或者UUID）。同时，这个键值对会设置一个TTL，表示锁的过期时间。如果这个键值对创建成功，那么就表示客户端成功获取到了锁。如果键值对创建失败（通常是因为键已经存在，即锁已经被其他客户端持有），那么客户端就没有获取到锁。&#xA;持有锁：一旦客户端获取到锁，就可以执行需要同步的操作。在这个过程中，其他客户端无法获取到锁，也就无法执行相同的操作。&#xA;释放锁：客户端在完成需要同步的操作后，需要释放锁，让其他客户端有机会获取锁。释放锁是通过调用ETCD的Delete操作，删除对应的键值对来实现的。&#xA;锁的过期：如果客户端在持有锁的过程中崩溃，可能无法正常释放锁。这时，ETCD的TTL特性就会发挥作用。ETCD会在键值对的TTL时间到达后，自动删除这个键值对，从而释放锁。这样可以防止因为客户端崩溃导致的锁无法释放，阻塞其他客户端的问题。&#xA;等待锁：如果客户端尝试获取锁失败（即锁已经被其他客户端持有），那么客户端可以选择等待锁被释放。这通常是通过轮询的方式实现的，客户端会定期尝试获取锁，直到成功为止。&#xA;通过这种方式，ETCD可以在分布式环境下实现锁的同步，保证在同一时刻，只有一个客户端能够执行需要同步的操作。这对于保证分布式系统的数据一致性非常重要。</description>
    </item>
    <item>
      <title>跨域问题处理方案</title>
      <link>https://ycchi0.github.io/posts/%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F/</link>
      <pubDate>Thu, 30 May 2024 16:27:47 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E5%A4%84%E7%90%86%E8%B7%A8%E5%9F%9F/</guid>
      <description>使用 Nginx 反向代理处理跨域问题 在 Nginx 配置文件中设置一个代理服务器，并添加一些额外的头信息。&#xA;location /api/ { add_header &amp;#39;Access-Control-Allow-Origin&amp;#39; &amp;#39;*&amp;#39;; add_header &amp;#39;Access-Control-Allow-Methods&amp;#39; &amp;#39;GET, POST, OPTIONS&amp;#39;; add_header &amp;#39;Access-Control-Allow-Headers&amp;#39; &amp;#39;DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range&amp;#39;; add_header &amp;#39;Access-Control-Expose-Headers&amp;#39; &amp;#39;Content-Length,Content-Range&amp;#39;; proxy_pass http://target.com; } 然后重启 Nginx 以应用这些更改：&#xA;在 Vue.js 项目中处理跨域问题 在vue.config.js文件中，配置 devServer.proxy 选项来设置代理规则。例如：&#xA;module.exports = { devServer: { host: &amp;#34;127.0.0.1&amp;#34;, port: 8084, open: true, proxy: { &amp;#34;/api&amp;#34;: { // &amp;#39;/api&amp;#39;是代理标识，用于告诉node，url前面是/api的就是使用代理的 target: &amp;#34;http://xxx.xxx.xx.xx:8080&amp;#34;, //目标地址，一般是指后台服务器地址 changeOrigin: true, //是否跨域 pathRewrite: { // pathRewrite 的作用是把实际Request Url中的&amp;#39;/api&amp;#39;用&amp;#34;&amp;#34;代替 &amp;#34;^/api&amp;#34;: &amp;#34;&amp;#34;, }, }, }, }, }; 保存并重启 Vue 开发服务器，新的代理设置应该就生效了。 注意：这种方法只在开发环境中有效，因为它依赖于 Vue CLI 的开发服务器。在生产环境中，你可能需要在你的后端服务器上设置 CORS 或使用其他方法来处理跨域问题。</description>
    </item>
    <item>
      <title>Redis 缓存设计</title>
      <link>https://ycchi0.github.io/posts/redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</link>
      <pubDate>Thu, 30 May 2024 09:55:49 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/redis%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/</guid>
      <description>典型 Web 应用缓存设计架构 在一个典型的 Web 应用中，从前端请求到 Nginx 再到后端服务的多级缓存设计可以如下：&#xA;浏览器缓存：这是最接近用户的一级缓存。浏览器会根据 HTTP 的缓存控制头字段（如 Expires、Cache-Control、Last-Modified、ETag 等）来决定是否需要向服务器发送请求，还是直接从本地缓存中获取资源。&#xA;CDN 缓存：内容分发网络（CDN）是一种常见的缓存策略，它可以将内容缓存到离用户最近的节点，从而减少网络延迟。当用户的请求到达 CDN 节点时，如果节点中有缓存的内容，就直接返回给用户；如果没有，就向源服务器请求内容，并将内容缓存到节点中。&#xA;Nginx 缓存：Nginx 是一种常见的反向代理服务器，它可以将后端服务器的响应缓存起来，从而减少对后端服务器的请求。当用户的请求到达 Nginx 时，如果 Nginx 中有缓存的响应，就直接返回给用户；如果没有，就向后端服务器请求内容，并将响应缓存起来。&#xA;应用服务器本地缓存：应用服务器可以使用本地内存作为缓存，存储经常访问的数据。这样，对于相同的请求，应用服务器可以直接从本地缓存中获取数据，而不需要访问数据库或者分布式缓存。这种缓存的优点是访问速度快，但是缺点是无法在多个应用服务器之间共享数据。&#xA;分布式缓存：当数据不在应用服务器的本地缓存中时，应用服务器可以从分布式缓存（如 Redis 或 Memcached）中获取数据。分布式缓存可以在多个应用服务器之间共享数据，但是访问速度相对于本地缓存会慢一些。&#xA;数据库缓存：数据库也有自己的缓存机制，例如 MySQL 的查询缓存。当收到相同的查询请求时，数据库可以直接从缓存中返回结果，而不需要再次执行查询。&#xA;在这个过程中，每一级缓存都可以减少对下一级的访问，从而提高系统的性能。&#xA;但是，也需要注意缓存的更新和失效问题，以保证数据的一致性。&#xA;缓存设计 在设计缓存系统时，我们需要考虑以下几个问题：&#xA;缓存穿透 缓存穿透是指用户查询的数据既不在缓存中，也不在数据库中，这样的查询请求就会“穿透”缓存层，直接请求数据库。这种情况通常发生在用户查询一些不存在的数据时。&#xA;例如，假设我们有一个商品信息的系统，用户可以通过商品 ID 查询商品信息。&#xA;当用户查询一个不存在的商品 ID 时，系统首先会在缓存中查找，如果没有找到，就会去数据库中查找。但是因为这个商品 ID 不存在，所以数据库中也找不到。这样，每次查询这个商品 ID，都会直接访问数据库，而不会利用到缓存。&#xA;如果有大量这样的查询请求，就会给数据库带来很大的压力，可能导致数据库崩溃。这就是缓存穿透。&#xA;为了防止缓存穿透，常见的解决方案有：&#xA;过滤非法请求：在应用层增加校验，对于用户的输入进行校验，过滤掉不存在的查询。&#xA;使用布隆过滤器：布隆过滤器是一种数据结构，它可以用来判断一个元素是否在一个集合中。我们可以将所有可能存在的数据哈希到布隆过滤器中，当用户查询数据时，先在布隆过滤器中查找，如果布隆过滤器判断数据不存在，就直接返回，不再查询缓存和数据库。&#xA;缓存空对象：即使数据库中没有数据，也将“空”结果进行缓存，但是这种缓存的有效期通常设置得比较短。&#xA;缓存击穿 缓存击穿是指当某个热点数据的缓存过期失效的瞬间，大量的请求同时涌入，这些请求都会穿透缓存直接请求数据库，可能会导致数据库瞬间压力过大。&#xA;举个例子，假设一个电商网站的某个热销商品信息被大量用户频繁查询，这个商品信息在缓存中有对应的缓存项。&#xA;然而，当这个缓存项到达过期时间，还没有来得及被更新，此时又有大量的请求涌入查询这个商品信息，这些请求会直接打到数据库上，可能会导致数据库压力过大，甚至崩溃，这就是缓存击穿。&#xA;为了防止缓存击穿，常见的解决方案有：&#xA;设置热点数据永不过期：对于一些访问非常频繁的热点数据，可以设置其在缓存中永不过期，或者在程序中控制在缓存失效后立即重新加载。&#xA;使用互斥锁：当缓存失效的时候，不是立即去加载数据库，而是先使用缓存工具的某些带成功操作返回值的操作（比如 Redis 的 SETNX 或者 Memcached 的 ADD），当操作返回成功时，再去加载数据库，否则，就重试获取缓存。这样可以保证对于一个 key，数据库只会被加载一次。&#xA;使用缓存预热策略：缓存预热就是系统上线后，将可能被用户访问的数据主动加载到缓存中，这样用户在访问数据时，就已经在缓存中了。可以通过定时任务，在非高峰时间对可能的热点数据进行预热，加载到缓存中。&#xA;设置不同的过期时间：为了避免大量的缓存同时过期，可以为每个缓存设置不同的过期时间，比如在一个基础过期时间上加上一个随机值。&#xA;缓存雪崩 缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样， 打向后端存储层。</description>
    </item>
    <item>
      <title>Redis的单线程和高性能</title>
      <link>https://ycchi0.github.io/posts/redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/</link>
      <pubDate>Thu, 30 May 2024 09:12:51 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/redis%E7%9A%84%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%92%8C%E9%AB%98%E6%80%A7%E8%83%BD/</guid>
      <description>Redis是单线程吗？ Redis 的单线程主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。&#xA;但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其 实是由额外的线程执行的。&#xA;Redis 单线程如何处理那么多的并发客户端连接？ Redis的IO多路复用：redis利用epoll来实现IO多路复用，将连接信息和事件放到队列中，依次放到文件事件分派器，事件分派器将事件分发给事件处理器。&#xA;Redis 单线程为什么还能这么快？ 因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程的切换性能损耗问题。&#xA;正因为 Redis 是单线程，所以要小心使用 Redis 指令，对于那些耗时的指令(比如keys)，一定要谨慎使用，一不小心就可能会导致 Redis 卡顿。&#xA;Redis 遍历 keys 用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时，性能比较差，要避免使用。&#xA;在需要遍历的场景下，需要使用 scan 命令进行渐进式遍历&#xA;SCAN cursor [MATCH pattern] [COUNT count] scan 参数提供了三个参数，第一个是 cursor 整数值(hash桶的索引值)，第二个是 key 的正则模式，第三个是一次遍历的key的数量(参考值，底层遍历的数量不一定)，并不是符合条件的结果数量。第一次遍历时，cursor 值为 0，然后将返回结果中第一个整数值作为下一次遍历的 cursor。一直遍历 到返回的 cursor 值为 0 时结束。&#xA;注意：但是scan并非完美无瑕， 如果在scan的过程中如果有键的变化（增加、 删除、 修改） ，那么遍历效果可能会碰到如下问题： 新增的键可能没有遍历到， 遍历出了重复的键等情况， 也就是说scan并不能保证完整的遍历出来所有的键， 这些是我们在开发时需要考虑的。</description>
    </item>
    <item>
      <title>Redis核心数据结构及应用场景</title>
      <link>https://ycchi0.github.io/posts/redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 30 May 2024 08:00:45 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>五种核心数据结构及其应用场景 String 最基本的类型，一个 key 对应一个 value，value 其实不仅可以是 String，也可以是数字。常规 key-value 缓存应用。&#xA;应用场景&#xA;缓存： 如果我们有一个用户信息，用户 ID 为 123，用户信息为&amp;quot;John&amp;quot;，我们可以这样存储：&#xA;SET user:123 &amp;#34;John&amp;#34; 当我们需要获取这个用户的信息时，我们可以这样获取：&#xA;GET user:123 计数器：&#xA;如果我们需要对一个网页的访问次数进行计数，我们可以这样操作：&#xA;INCR page_view:1 每当有新的访问时，我们就执行上面的命令，这样就可以实时统计网页的访问次数。&#xA;分布式锁：&#xA;如果我们需要对一个资源进行加锁，我们可以这样操作：&#xA;SET lock:resource_name &amp;#34;lock_value&amp;#34; NX EX 30 这个命令会尝试设置一个键，如果这个键不存在，那么设置成功，我们就获取到了锁，如果这个键已经存在，那么设置失败，我们就没有获取到锁。EX 参数表示这个键的过期时间，这样可以防止死锁。&#xA;会话缓存：&#xA;如果我们需要存储一个用户的会话信息，我们可以这样操作：&#xA;SET session:123 &amp;#34;session_info&amp;#34; 当我们需要获取这个用户的会话信息时，我们可以这样获取：&#xA;GET session:123 页面缓存：&#xA;如果我们需要缓存一个网页的内容，我们可以这样操作：&#xA;SET page:1 &amp;#34;page_content&amp;#34; 当我们需要获取这个网页的内容时，我们可以这样获取：&#xA;GET page:1 分布式系统全局序列号&#xA;redis 批量生成序列号提升性能&#xA;INCRBY orderId 1000 Hash 用于存储对象，即多个字段及字段值，通过 key 和字段名（field）来唯一确定一个值。适合用于存储对象。&#xA;应用场景&#xA;存储对象：哈希表是存储对象的理想选择。例如，如果你有一个用户对象，你可以使用用户的 ID 作为键，用户的其他信息（如姓名、电子邮件等）作为值。&#xA;示例：&#xA;HSET user:1000 name &amp;#34;John Doe&amp;#34; HSET user:1000 email &amp;#34;john.</description>
    </item>
    <item>
      <title>Explain详解与索引最佳实践</title>
      <link>https://ycchi0.github.io/posts/explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Thu, 30 May 2024 06:44:34 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid>
      <description>Explain Explain是MySQL中的一个非常有用的工具，它可以帮助我们理解MySQL是如何执行SQL查询的。&#xA;通过使用Explain，我们可以看到查询的执行计划，包括使用了哪些索引，表的连接顺序，预计要扫描的行数等信息。&#xA;这些信息可以帮助我们优化查询，提高查询效率。&#xA;EXPLAIN SELECT * FROM users WHERE id = 1; Explain的结果包含以下几个重要的列：&#xA;id 查询的标识符，如果一个查询包含多个子查询，那么每个子查询都会有一个不同的id。&#xA;select_type 表示对应行是简单还是复杂的查询。&#xA;simple：简单查询。查询不包含子查询和union primary：复杂查询中最外层的 select subquery：包含在 select 中的子查询（不在 from 子句中） derived：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） CREATE TABLE customers ( id INT PRIMARY KEY, name VARCHAR(50) ); CREATE TABLE orders ( id INT PRIMARY KEY, customer_id INT, amount DECIMAL(10, 2) ); INSERT INTO customers (id, name) VALUES (1, &amp;#39;John&amp;#39;), (2, &amp;#39;Jane&amp;#39;), (3, &amp;#39;Bob&amp;#39;); INSERT INTO orders (id, customer_id, amount) VALUES (1, 1, 100.</description>
    </item>
    <item>
      <title>深入理解MySQL索引底层数据结构</title>
      <link>https://ycchi0.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Thu, 30 May 2024 05:27:40 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>索引是什么 索引是帮助MySQL高效获取数据的排好序的数据结构。&#xA;InnoDB 索引实现 InnoDB 存储引擎使用一种称为 B+Tree 的数据结构来实现其索引。B+Tree 是 B-Tree 的一种变体，它在数据库索引中的应用非常广泛。&#xA;B+树是一种自平衡的树，可以保持数据有序。这种数据结构可以大大加快数据的检索速度，尤其是在处理大量数据时。&#xA;在B+树中，所有的数据都存储在叶子节点，而非叶子节点只存储关键字和子节点的指针。&#xA;同时，叶子节点之间通过指针相连，这样可以提高范围查询的效率。MySQL 对b+ 树做了优化,叶子节点之间是双向连接，标准的 b+ 树是从左指向右,单向连接&#xA;此外，MySQL还支持哈希索引，但是哈希索引只能满足&amp;quot;=&amp;quot;,&amp;ldquo;IN&amp;rdquo; 和&amp;quot;&amp;lt;=&amp;gt;&amp;ldquo;查询，不能使用范围查询和排序，所以B+树是MySQL的主要索引结构。&#xA;InnoDB 存储引擎有两种类型的索引：主键索引（聚簇索引）和二级索引（非聚簇索引）。&#xA;主键索引 InnoDB 的数据是按照主键顺序存放的，也就是说主键索引的叶子节点就是数据节点。因此，按照主键查询可以直接通过索引找到数据，效率非常高。&#xA;二级索引 二级索引的叶子节点并不包含行记录的全部数据。相反，它的叶子节点包含的是对应行数据的主键值。当通过二级索引查找时，InnoDB 会先找到二级索引指向的主键，然后再通过主键索引找到完整的行数据。这就是所谓的“回表”。&#xA;MyISAM 的索引 MyISAM索引文件和数据文件是分离的。在MyISAM存储引擎中，每个表被存储为三个文件。一个是表定义文件（.frm），一个是数据文件（.MYD），还有一个是索引文件（.MYI）。&#xA;数据文件和索引文件是分离的，这也是MyISAM的一个特点。 数据文件存储了表的数据，而索引文件则存储了表的索引信息。这种分离的设计使得MyISAM在处理大量数据时具有一定的优势，因为索引和数据可以分别进行IO操作，提高了数据处理的效率。&#xA;但是，这种设计也有一些缺点。例如，如果在操作过程中发生故障，可能会导致数据文件和索引文件之间的不一致，从而影响数据的完整性。此外，MyISAM不支持事务，这也是其在某些场景下被InnoDB等其他存储引擎所取代的原因。&#xA;为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键？ InnoDB 存储引擎在存储数据时，会按照主键的顺序进行存储。&#xA;如果没有主键，InnoDB 会选择一个唯一非空索引代替，如果这样的索引也没有，InnoDB 会生成一个隐藏的聚簇索引。&#xA;这个隐藏的聚簇索引会占用额外的存储空间，而且由于它不是由用户定义的，所以在执行查询时可能会导致性能下降。&#xA;使用整型的自增主键有以下几个优点：&#xA;整型的自增主键可以保证数据的插入顺序，这样可以避免页面分裂，提高插入效率 整型的自增主键占用的空间小，可以减少索引的存储空间，提高查询效率。 自增主键可以避免主键的重复，保证数据的唯一性。 使用自增主键，可以避免在插入数据时需要手动指定主键值，简化了插入操作 为什么非主键索引结构叶子节点存储的是主键值？ 简单来说就是为了一致性和节省存储空间。&#xA;在InnoDB存储引擎中，非主键索引（也称为二级索引）的叶子节点存储的是主键值，这是由InnoDB的存储结构决定的。&#xA;InnoDB使用聚簇索引（也就是主键索引）来存储数据，这意味着表中的数据实际上是按照主键的顺序存储的。因此，主键值实际上就是数据行在物理存储上的地址。&#xA;当我们通过非主键索引进行查询时，InnoDB首先会在非主键索引中查找到主键值，然后再通过主键值在聚簇索引中查找到实际的数据行。这个过程通常被称为“回表”。&#xA;这样设计的好处是，非主键索引可以更小，因为它只需要存储主键值，而不需要存储整行数据。这可以节省存储空间，提高IO效率。同时，由于所有的非主键索引都引用了主键，所以在更新数据时，只需要更新聚簇索引，而不需要更新每一个非主键索引，这也可以提高更新操作的效率。&#xA;但是，这也意味着如果频繁地进行非主键索引查询，可能会导致大量的“回表”操作，从而影响查询性能。因此，在设计数据库时，需要根据实际的查询需求来合理选择使用主键索引还是非主键索引。&#xA;索引最左前缀原理 最左前缀原理，也被称为最左前缀匹配原则，是指在多列索引中，查询可以只使用索引的最左边的一部分，但必须是连续的部分。这是因为多列索引是按照列的顺序，从左到右进行排序的。&#xA;例如，如果我们有一个包含三列（A，B，C）的索引，那么以下查询可以使用索引： 查询只涉及到 A 列。 查询涉及到 A 和 B 列。 查询涉及到 A，B 和 C 列。&#xA;但是，如果查询只涉及到 B 列或者 C 列，或者涉及到 A 和 C 列（跳过了 B 列），那么索引将不会被使用。这就是最左前缀原理。</description>
    </item>
    <item>
      <title>常见的限流算法</title>
      <link>https://ycchi0.github.io/posts/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</link>
      <pubDate>Tue, 28 May 2024 11:11:22 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/</guid>
      <description>限流 通过限制并发访问数或者限制一个时间窗口内允许处理的请求数量来保护系统，例如，通过限流，你可以过滤掉产生流量峰值的客户和服务。&#xA;令牌桶算法 令牌桶算法是常见的一种限流算法。假设有一个桶，以固定速度（rate）往桶里加入令牌（token）。当桶满了时停止加入。服务收到请求时尝试从桶里取出令牌。如果成功取出，则可以响应本次请求。如果没有取到，可以进行有限时间的等待或者返回超时错误。&#xA;特点 遇到流量洪峰时可以应对部分突发流量，但由于桶有容量上限，当消耗完桶里堆积的令牌之后只能根据令牌的生成速率提供服务，从而起到限流的作用。&#xA;Golang 实现 Golang rate包提供了 token limiter 的实现,具体可以点击链接查看rate package&#xA;漏桶算法 一个固定容量的漏桶，按照常量固定速率流出水滴，这里的水滴指的就是能进行响应的请求。当漏桶满了时，请求就会被丢弃，返回一个限流标志。&#xA;特点 流量均匀，一般作为计量工具，可以用于流量整形和流量控制。比方说对数据库的操作。经过一层漏桶控制，可以有效控制对数据库的请求，避免数据库被打挂。流量稳定，但是无法应对突发流量。&#xA;Golang 实现 uber 开源了一个基于漏桶的限流器ratelimit&#xA;func main() { rl := ratelimit.New(1) // per second for i := 0; i &amp;lt; 10; i++ { now := rl.Take() if i &amp;gt; 0 { fmt.Println(i, now) } } } 1 2022-03-24 02:24:51.57952663 2 2022-03-24 02:24:52.579526624 3 2022-03-24 02:24:53.579526623 4 2022-03-24 02:24:54.579526617 5 2022-03-24 02:24:55.579526616 6 2022-03-24 02:24:56.</description>
    </item>
    <item>
      <title>Golang异常处理</title>
      <link>https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Tue, 28 May 2024 11:02:44 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/golang%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>从error的定义说起 type error interface { Error() string } Go 的error类型是一个接口。在Go中，只要实现了接口约定的方法，就等同于实现了这个接口。在日常的业务代码编写中，我们经常使用 errors 包下的New 方法来生成一个error对象。&#xA;func main() { err := errors.New(&amp;#34;a error&amp;#34;) fmt.Println(reflect.TypeOf(err))//*errors.errorString } 可以发现，err 是一个指针类型，为什么这里的 err 需要是一个指针呢？&#xA;// Each call to New returns a distinct error value even if the text is identical. func New(text string) error { return &amp;amp;errorString{text} } 查看errors包的代码，我们知道返回指针是为了确保err的唯一性。&#xA;以下的代码是返回一个变量会引起的问题。&#xA;type ValueError string func (ve ValueError) Error() string { return string(ve) } func New(text string) error { return ValueError(text) } func main() { simpleError := New(&amp;#34;error&amp;#34;) complexError := New(&amp;#34;error&amp;#34;) if simpleError == complexError { fmt.</description>
    </item>
    <item>
      <title>服务治理之布隆过滤器</title>
      <link>https://ycchi0.github.io/posts/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Tue, 28 May 2024 11:01:20 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E6%9C%8D%E5%8A%A1%E6%B2%BB%E7%90%86%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description>布隆过滤器 布隆过滤器（英语：Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。元素可以添加到集合中，但不能删除(计数布鲁姆过滤器变体支持删除);&#xA;作用 布隆过滤器可以用于判断一个元素可能存在或者一定不存在。&#xA;参考文章 Bloom filter https://segmentfault.com/a/1190000021136424 go-zero 中的实现 go-zero 中基于 redis 实现了布隆过滤器 通过 lua 脚本 setbit 和 getbit&#xA;setScript = ` for _, offset in ipairs(ARGV) do redis.call(&amp;#34;setbit&amp;#34;, KEYS[1], offset, 1) end ` testScript = ` for _, offset in ipairs(ARGV) do if tonumber(redis.call(&amp;#34;getbit&amp;#34;, KEYS[1], offset)) == 0 then return false end end 使用 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;github.com/zeromicro/go-zero/core/bloom&amp;#34; &amp;#34;github.com/zeromicro/go-zero/core/stores/redis&amp;#34; ) func main() { store := redis.</description>
    </item>
    <item>
      <title>MySQL关于only_full_group_by限制</title>
      <link>https://ycchi0.github.io/posts/mysql%E5%85%B3%E4%BA%8Eonly_full_group_by%E9%99%90%E5%88%B6/</link>
      <pubDate>Tue, 28 May 2024 10:56:23 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/mysql%E5%85%B3%E4%BA%8Eonly_full_group_by%E9%99%90%E5%88%B6/</guid>
      <description>先上结论&#xA;如果 only_full_group_by 被启用，那么在查询时，如果某个列不在group by 列表中，此时如果不对该列进行聚合处理，则该列不能出现在 select 列表，having 条件中及order by 列表中&#xA;MySQL 8.0 默认启用了sql_mode，我们可以通过 select @@session.sql_mode 查看会话中的 sql_mode 配置。&#xA;mysql&amp;gt; SELECT @@session.sql_mode; +-----------------------------------------------------------------------------------------------------------------------+ | @@session.sql_mode | +-----------------------------------------------------------------------------------------------------------------------+ | ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION | +-----------------------------------------------------------------------------------------------------------------------+ 1 row in set (0.00 sec) 有这么一张表&#xA;CREATE TABLE `mytable` ( `id` int unsigned NOT NULL, `a` varchar(10) COLLATE utf8mb4_general_ci DEFAULT NULL, `b` int DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE = InnoDB DEFAULT CHARSET = utf8mb4 COLLATE = utf8mb4_general_ci; INSERT INTO mytable VALUES (1, &amp;#39;abc&amp;#39;, 1000), (2, &amp;#39;abc&amp;#39;, 2000), (3, &amp;#39;def&amp;#39;, 4000); 当我们执行的 SQL 语句包含聚合函数时，MYSQL 提示需要使用 GROUP BY 进行分组。</description>
    </item>
    <item>
      <title>SQL基础</title>
      <link>https://ycchi0.github.io/posts/sql%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Tue, 28 May 2024 10:51:29 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/sql%E5%9F%BA%E7%A1%80/</guid>
      <description>前言 在平时的工作中，大家可能是 ORM 战士。但是 ORM 之下，还是原生的 SQL。这是整理 SQL 基础时的一些记录。&#xA;DDL 数据定义语言,用来定义数据库对象，包括数据库、数据表和列。&#xA;DML 数据操作语言，用来操作和数据库相关的记录，比如增加、删除、修改数据表中的记录。&#xA;DCL 数据控制语言，用来定义访问权限和安全级别。&#xA;DQL 数据查询语言，用来查询想要的记录。&#xA;SQL语句书写规范 参考：&#xA;表名、表别名、字段名、字段别名等都小写&#xA;SQL 保留字、函数名、绑定变量等都大写&#xA;SQL 排序 ORDER BY ORDER BY 后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。 ORDER BY 后面可以注明排序规则，ASC 代表递增排序，DESC 代表递减排序。默认情况下是按照 ASC 递增排序。 ORDER BY 可以使用非选择列进行排序，即使在 SELECT 后面没有这个列名，同样可以放到 ORDER BY 后面进行排序。 SELECT 的执行顺序 1.关键字语法顺序 SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ... 其中 WHERE 和 HAVING 的区别在于，WHERE 是对数据行进行过滤，而 HAVING 是对分组数据进行过滤。&#xA;2.语句的执行顺序(以MySQL为例) FROM &amp;gt; WHERE &amp;gt; GROUP BY &amp;gt; HAVING &amp;gt; SELECT 的字段 &amp;gt; DISTINCT &amp;gt; ORDER BY &amp;gt; LIMIT (5)SELECT DISTINCT &amp;lt;select_list&amp;gt; (1)FROM &amp;lt;left_table&amp;gt; &amp;lt;join_type&amp;gt; JOIN &amp;lt;right_table&amp;gt; ON &amp;lt;on_predicate&amp;gt; (2)WHERE &amp;lt;where_predicate&amp;gt; (3)GROUP BY &amp;lt;group_by_specification&amp;gt; (4)HAVING &amp;lt;having_predicate&amp;gt; (6)ORDER BY &amp;lt;order_by_list&amp;gt; (7)LIMIT n, m 这些步骤执行时，每个步骤都会产生一个虚拟表，该虚拟表被用作下一个步骤的输入。这些虚拟表对调用者（客户端应用程序或者外部查询）无感知的。只有最后一步生成的表才会返回给调用者。如果没有在查询中指定某一子句，将跳过相应的步骤。</description>
    </item>
    <item>
      <title>CSS清除浮动</title>
      <link>https://ycchi0.github.io/posts/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</link>
      <pubDate>Tue, 28 May 2024 08:50:13 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/</guid>
      <description>谈谈 BFC 当一个盒子没有设置 height, 而子盒子又都设置浮动时，此时这个盒子会塌陷。 如下：&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; .box { width: 600px; border: 10px solid #a89393; } .box .c1 { width: 300px; height: 200px; background-color: orange; float: left; } .box .c2 { width: 300px; height: 200px; background-color: blue; float: left; } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;box&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;c1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;c2&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 造成这个现象的原因，就是这个父盒子没有产生 BFC。&#xA;那么什么是 BFC 呢 ？ 根据 MDN 的定义，BFC(区块格式化上下文)是 Web 页面的可视 CSS 渲染的一部分，是块级盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。 下列方式会创建块格式化上下文： 本质上来说，只要创建了 BFC,浮动的问题就解决了。</description>
    </item>
    <item>
      <title>Vif和vshow</title>
      <link>https://ycchi0.github.io/posts/vif%E5%92%8Cvshow/</link>
      <pubDate>Fri, 24 May 2024 13:13:11 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/vif%E5%92%8Cvshow/</guid>
      <description>v-if 与 v-show 的共同点 v-if v-show 都是 Vue 中用来控制元素显示与否的。&#xA;v-if 与 v-show 的区别 v-show隐藏则是为该元素添加css&amp;ndash;display:none，dom元素依旧还在。v-if显示隐藏是将dom元素整个添加或删除&#xA;v-show 由false变为true的时候不会触发组件的生命周期&#xA;v-if由false变为true的时候，触发组件的beforeCreate、create、beforeMount、mounted钩子，由true变为false的时候触发组件的beforeDestory、destoryed方法&#xA;v-if 与 v-show 的使用场景 需要非常频繁地切换，则使用 v-show 较好&#xA;运行时条件很少改变时，则使用 v-if 较好</description>
    </item>
    <item>
      <title>在 VUE 中 ，如何正确使用 Compute、Watch 和 Methods </title>
      <link>https://ycchi0.github.io/posts/vue_compute_watch_function/</link>
      <pubDate>Fri, 24 May 2024 12:49:58 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/vue_compute_watch_function/</guid>
      <description>Vue 中 computed, watch 和 methods 区别 在Vue 中，我们有几种处理数据和逻辑的方式。&#xA;本文将重点探讨computed, watch 和 methods 的区别和使用场景。&#xA;computed 在Vue中，computed用于处理依赖其他属性的计算结果。它是由缓存的，只有当依赖项发生更改时，才会重新计算其结果。&#xA;setup() { const count = ref(0); const doubled = computed(() =&amp;gt; count.value * 2); return { count, doubled } } 我们创建了一个计算属性doubled，将count进行了两倍的计算。每当 count 更新时，doubled 也会自动更新。&#xA;watch watch用于观察和响应Vue组件中的数据更改。当被观察的数据源发生改变时，会触发一个回调函数。&#xA;在Vue中，computed和watch是两种常见的监听数据变化和执行逻辑的手段。它们在用法和应用场景上存在一些区别：&#xA;computed: 它用于处理依赖其他变量的计算结果。比如，你有两个变量 a 和 b，你想创建第三个变量 c，它是 a 和 b 的和。在这种情况下，你应该使用 computed。computed 属性有一个缓存机制，当依赖项没有发生改变时，它会直接返回上一次的计算结果，而不会再次执行函数。&#xA;watch: 它用来观察vue实例上的数据变动。需要注意的是，watch 是非缓存的，即只要观察的目标发生变化 watch 就会执行，无论是否真的需要（依赖的数据是否真正发生了改变）。watch 更适合于例如：当数据变化时需要执行异步或者较长时间的操作的场景。&#xA;另外 watch 还有跟多高阶用法和特性，本文不做讨论，具体可查询VUE 文档&#xA;下面的例子中，我们观察count的变化，并在每次count变化时打印出变化后和变化前的值。&#xA;setup() { const count = ref(0); watch(count, (newValue, oldValue) =&amp;gt; { console.</description>
    </item>
    <item>
      <title>VUE生命周期函数</title>
      <link>https://ycchi0.github.io/posts/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 24 May 2024 11:39:34 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0/</guid>
      <description>学习 VUE, 就不得不了解 VUE 的生命周期函数。 下面这张图来自 VUE 官网&#xA;其中 setup 函数是 VUE3 新加入的特性， 通过组合式 API 可以让我们的代码更具有可读性和可维护性。&#xA;我们随便写点代码来验证一下&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;zh&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;VUE3 生命周期学习&amp;lt;/title&amp;gt; &amp;lt;script src=&amp;#34;https://unpkg.com/vue@3/dist/vue.global.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div id=&amp;#34;app&amp;#34;&amp;gt; &amp;lt;button @click=&amp;#34;changeMessage&amp;#34;&amp;gt;改变信息&amp;lt;/button&amp;gt; &amp;lt;button @click=&amp;#34;unmountComponent&amp;#34;&amp;gt;卸载组件&amp;lt;/button&amp;gt; &amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt; &amp;lt;child-component v-if=&amp;#34;!componentUnmounted&amp;#34; :message=&amp;#34;message&amp;#34; &amp;gt;&amp;lt;/child-component&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;script&amp;gt; const ChildComponent = { props: [&amp;#34;message&amp;#34;], beforeUnmount() { console.log(&amp;#34;beforeUnmount&amp;#34;); }, unmounted() { console.log(&amp;#34;unmounted&amp;#34;); }, template: `&amp;lt;p&amp;gt;{{ message }}&amp;lt;/p&amp;gt;`, }; const App = { data() { return { message: &amp;#34;Hello Vue3&amp;#34;, componentUnmounted: false, }; }, components: { &amp;#34;child-component&amp;#34;: ChildComponent, }, beforeCreate() { console.</description>
    </item>
    <item>
      <title>Box Sizing</title>
      <link>https://ycchi0.github.io/posts/box-sizing/</link>
      <pubDate>Fri, 24 May 2024 02:53:44 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/box-sizing/</guid>
      <description>CSS 中的 box-sizing 属性定义了 user agent 应该如何计算一个元素的总宽度和总高度。&#xA;怎么理解呢？&#xA;首先先明确一点，默认情况下，元素的宽度(width) 和高度(height)计算方式为：&#xA;width(宽度) + padding(内边距) + border(边框) = 元素实际宽度 height(高度) + padding(内边距) + border(边框) = 元素实际高度&#xA;而 box-sizing 属性可以被用来调整这些表现&#xA;content-box 是默认值。如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box ：设置的边框和内边距的值是包含在 width 内的。也就是说，如果你将一个元素的 width 设为 100px，那么这 100px 会包含它的 border 和 padding，内容区的实际宽度是 width 减去 (border + padding) 的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。 我们来看下面的图： content-box 情况： border-box 情况： 浏览器兼容性如下： 参考文档MDN box-sizing</description>
    </item>
    <item>
      <title>CSS 浮动</title>
      <link>https://ycchi0.github.io/posts/css%E6%B5%AE%E5%8A%A8/</link>
      <pubDate>Thu, 23 May 2024 18:22:30 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/css%E6%B5%AE%E5%8A%A8/</guid>
      <description>先谈谈浮动 float 很多网站的布局都是通过 float 实现的，浮动最本质的功能就是用来实现并排。&#xA;一个例子 先来看一个例子，有三个未设置浮动的盒子，代码如下：&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;style&amp;gt; .box { width: 600px; height: 200px; border: 1px solid #000; } .box .c1 { width: 200px; height: 200px; background-color: orange; /* float: left; */ } .box .c2 { width: 200px; height: 200px; background-color: green; /* float: left; */ } .box .c3 { width: 200px; height: 200px; background-color: blue; /* float: left; */ } &amp;lt;/style&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;div class=&amp;#34;box&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;c1&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;c2&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;c3&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 当我们给三个盒子都设置浮动，即取消上面代码注释部分，盒子便可以横向编排。 浮动使用要点 浮动在使用时，有两个要点</description>
    </item>
    <item>
      <title>Art Template</title>
      <link>https://ycchi0.github.io/posts/art-template/</link>
      <pubDate>Thu, 23 May 2024 16:59:54 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/art-template/</guid>
      <description>art-template art-template 是一个简约、超快的模板引擎。采用作用域预声明的技术来优化模板渲染速度，从而获得接近 JavaScript 极限的运行性能，并且同时支持 NodeJS 和浏览器。&#xA;在一些动态渲染场景，使用 art-template 可以将 JS 代码与 Html 代码分开管理，便于项目维护。&#xA;比如说后端获取到一个 students 对象数组，现在要在界面上以列表的形式展示，我们可能会这样编写代码&#xA;student 对象数组为：&#xA;const students = [ { name: &amp;#34;xxx&amp;#34;, age: 18, }, { name: &amp;#34;yyy&amp;#34;, age: 28, }, { name: &amp;#34;zzz&amp;#34;, age: 20, }, ]; 使用模板字符串&#xA;const list = document.getElementById(&amp;#39;list&amp;#39;); let html = &amp;#39;&amp;#39;; for (const student of students) { html += `&amp;lt;li&amp;gt;${student.name} ${student.age}&amp;lt;/li&amp;gt;`; } list.innerHTML = html; 使用 art-template：&#xA;&amp;lt;script id=&amp;#34;tpl-students&amp;#34; type=&amp;#34;text/html&amp;#34;&amp;gt; {{each students}} &amp;lt;li&amp;gt;{{$value.</description>
    </item>
    <item>
      <title>谈谈Cookie</title>
      <link>https://ycchi0.github.io/posts/%E8%B0%88%E8%B0%88cookie/</link>
      <pubDate>Thu, 23 May 2024 15:30:15 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/%E8%B0%88%E8%B0%88cookie/</guid>
      <description>Cookie 是什么 Cookie 全称 HTTP Cookie，简称 Cookie,是浏览器存储数据的一种方式。Cookie 存储在用户本地，一般会自动随着浏览器每次请求发送到服务器端。&#xA;打开浏览器开发者工具，如下： Cookie 有什么用 可以利用 Cookie 跟踪统计用户访问该网站的习惯，比如什么时间访问，访问了哪些页面，在每个网页的停留时间等&#xA;注意：不要在 Cookie 中保存密码等敏感信息&#xA;Cookie 的基本用法 写入 Cookie &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; document.cookie = &amp;#34;username=zs&amp;#34;; document.cookie = &amp;#34;age=18&amp;#34;; &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 读取 Cookie &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;script&amp;gt; console.log(document.cookie); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Cookie 属性 最重要的两个属性 Cookie 的名称（Name）和值（Value） 是最重要的两个属性，创建 时必须填写，其它属性可以使用默认值。</description>
    </item>
    <item>
      <title>Webpack 从入门到放弃</title>
      <link>https://ycchi0.github.io/posts/webpack/</link>
      <pubDate>Thu, 23 May 2024 08:05:20 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/webpack/</guid>
      <description>Webpack 是什么 首先，webpack 是一个打包工具，它会根据代码的内容解析模块依赖，帮助我们把多个模块的代码打包。&#xA;借助一个官网的截图，让你感受一下 webpack 的强大。&#xA;日常使用的前端开发环境应该是怎样的？我们可以尝试着把基本前端开发环境的需求列一下：&#xA;构建我们发布需要的 HTML、CSS、JS 文件 使用 CSS 预处理器来编写样式 使用 Babel 来支持 ES 新特性 本地提供静态服务以方便开发调试 &amp;hellip;. 这些需求，使用 webpack 都可以较好的满足。&#xA;webpack 官方手册地址&#xA;先从一个简单的项目开始 1.初始化项目&#xA;npm init 2.安装 webpack 需要的包&#xA;npm install --save-dev webpack-cli@3.3.12 webpack@4.44.1 3.配置 webpack&#xA;在工程文件夹内新建 webpack.config.js&#xA;const path = require(&amp;#34;path&amp;#34;); module.exports = { entry: &amp;#34;./src/index.js&amp;#34;, output: { path: path.resolve(__dirname, &amp;#34;dist&amp;#34;), filename: &amp;#34;bundle.js&amp;#34;, }, }; 在 package.json 文件添加script命令：&#xA;&amp;#34;webpack&amp;#34;: &amp;#34;webpack --config webpack.config.js&amp;#34; 此时工程目录如下： 4.编译并测试&#xA;npm run webpack 执行命令后会发现工程目录下生成了 dist/bundle.</description>
    </item>
    <item>
      <title>Javascript Module 详解</title>
      <link>https://ycchi0.github.io/posts/javascript_module/</link>
      <pubDate>Wed, 22 May 2024 12:26:48 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/javascript_module/</guid>
      <description>什么是模块(Module) 模块，在 Js 可以看成一个一个局部作用域的代码块。&#xA;我们写代码时需要注意高内聚，低耦合，这就需要用到模块系统。它能帮助我们更好的划分代码功能，增加代码复用性，便于维护程序。&#xA;引入模块系统的好处：&#xA;代码模块化管理，便于复用 消除过多全局变量 管理加载顺序 Module 基本用法 一个文件就是一个模块。 如下是一个基本的用法： person.js&#xA;class Person { constructor(name) { this.name = name; } sayHi() { console.log(&amp;#34;hi&amp;#34;); } } export default Person; student.js&#xA;import Person from &amp;#34;./person&amp;#34;; class Student extends Person { constructor(name, age) { super(name); this.age = age; } } export default Student; index.js&#xA;import Student from &amp;#34;./student&amp;#34;; let s = new Student(&amp;#34;zs&amp;#34;,10); script 标签加载的时候，需要加上 type=&amp;ldquo;module&amp;rdquo; demo.html&#xA;&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.</description>
    </item>
    <item>
      <title>Javascript ES6 Class 深入浅出</title>
      <link>https://ycchi0.github.io/posts/javascript_es6_class/</link>
      <pubDate>Wed, 22 May 2024 01:29:33 +0000</pubDate>
      <guid>https://ycchi0.github.io/posts/javascript_es6_class/</guid>
      <description>初识 Class Javascript 中的类基于 Prototype 创建，一般类需要大写。 下面是一个简单的 Person 类示例，constructor 是构造函数，用来给类的对象进行初始化。&#xA;class Person { constructor(name, age) { //this 代表实例对象，上面定义的是实例属性/方法 this.name = name; this.age = age; } // 各实例共享的方法 sayHi() { console.log(&amp;#34;sayHi&amp;#34;); } } let zs = new Person(&amp;#34;zhangsan&amp;#34;, 18); zs.sayHi(); 上面的 Person 类等同于下面 Prototype-based 写法&#xA;function Person(name, age) { this.name = name; this.age = age; } Person.prototype.sayHi = function () { console.log(&amp;#34;Prototype-based&amp;#34;); }; let zs = new Person(&amp;#34;zhangsan&amp;#34;, 18); zs.sayHi(); 立即执行的匿名类 new (class { constructor() { console.</description>
    </item>
  </channel>
</rss>
