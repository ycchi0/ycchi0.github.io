<!DOCTYPE html>
<html lang="en" dir="auto">

<head>
	<meta name="generator" content="Hugo 0.129.0"><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Ycchi0 Blog</title>

<meta name="description" content="">
<meta name="author" content="">
<link rel="canonical" href="https://ycchi0.github.io/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css" integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z&#43;V9&#43;cO1A=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://ycchi0.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ycchi0.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ycchi0.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ycchi0.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ycchi0.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" type="application/rss+xml" href="https://ycchi0.github.io/index.xml">
<link rel="alternate" hreflang="en" href="https://ycchi0.github.io/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:title" content="Ycchi0 Blog" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ycchi0.github.io/" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Ycchi0 Blog"/>
<meta name="twitter:description" content=""/>

<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "Organization",
  "name": "Ycchi0 Blog",
  "url": "https://ycchi0.github.io/",
  "description": "",
  "thumbnailUrl": "https://ycchi0.github.io/favicon.ico",
  "sameAs": [
      
  ]
}
</script>
</head>

<body class="list" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ycchi0.github.io/" accesskey="h" title="Ycchi0 Blog (Alt + H)">Ycchi0 Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main"> 

<article class="first-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">013.Go入门 Range
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，range 是一个用于遍历各种数据结构的关键字，包括数组、切片、字符串、map 和通道。它提供了一种简洁、通用的方式来访问集合中的元素。
1. range 用于数组和切片 当 range 用于 数组 或 切片 时，它返回两个值：索引 和 元素的副本。
示例：range 遍历数组或切片 arr := []int{10, 20, 30, 40} for i, v := range arr { fmt.Printf(&#34;索引: %d, 值: %d\n&#34;, i, v) } 输出：
索引: 0, 值: 10 索引: 1, 值: 20 索引: 2, 值: 30 索引: 3, 值: 40 i 是索引 v 是该索引处元素的副本 只需要元素或索引时 如果只需要索引或值，可以使用 下划线_ 忽略不需要的值。
只需要索引： for i := range arr { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:56:40 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 013.Go入门 Range" href="https://ycchi0.github.io/posts/013.go%E5%85%A5%E9%97%A8-range/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">012.Go基础 Map
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，map是一种内置的数据结构，用于存储键值对（key-value pairs）。它非常类似于其他编程语言中的哈希表（hash table）或字典（dictionary）。Go 语言中的map提供了高效的键值查找、插入和删除操作，是处理关联数据的首选结构。
1. map 的定义和初始化 map的定义方式为map[keyType]valueType，其中keyType表示键的类型，valueType表示值的类型。
示例：定义一个map var m map[string]int // 声明一个key为string，value为int的map 在 Go 中，map的零值是nil，如果没有进行初始化就直接操作map，会导致运行时错误。因此，使用map之前必须先进行初始化。
1.1 使用 make 初始化 map Go 提供了内置的make函数来初始化map。
m := make(map[string]int) // 使用make函数创建一个map m[&#34;apple&#34;] = 5 m[&#34;banana&#34;] = 10 fmt.Println(m) // 输出 map[apple:5 banana:10] 在这个例子中，我们使用make函数初始化了一个map，并通过键值对的方式插入了两个元素。
1.2 使用字面量创建和初始化 map 除了使用make函数，map还可以通过字面量直接创建并初始化。
m := map[string]int{ &#34;apple&#34;: 5, &#34;banana&#34;: 10, } fmt.Println(m) // 输出 map[apple:5 banana:10] 这种方式不仅简洁，而且可以在声明时同时进行赋值。
2. map 的基本操作 2.1 插入元素 在map中插入元素的方式非常简单，直接通过map[key] = value的形式即可。
m := make(map[string]int) m[&#34;orange&#34;] = 20 // 插入键&#34;orange&#34;对应的值为20 2....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:56:21 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 012.Go基础 Map" href="https://ycchi0.github.io/posts/012.go%E5%9F%BA%E7%A1%80-map/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">011.Go基础 切片
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，切片（slice） 是一种非常重要的数据结构，它是对数组的抽象，是一个动态大小的序列。与数组不同，切片的长度是可以变化的，因而更灵活、更常用。切片本质上是对底层数组的引用，允许我们在不复制数据的情况下处理数组的某一部分。
1. 切片的定义与创建 切片由三部分组成：指针（指向底层数组的某个元素）、长度（当前切片中包含的元素数）和容量（从切片的起始位置到底层数组末尾的元素数）。
创建切片的方式有几种常见的方式： 1.1 使用现有数组创建切片 通过数组生成切片，可以通过array[start:end]的方式从数组中创建切片，切片不包含end位置的元素。
arr := [5]int{1, 2, 3, 4, 5} slice := arr[1:4] // 从数组创建切片，包含索引1到索引3的元素 fmt.Println(slice) // 输出 [2 3 4] 1.2 使用make()函数创建切片 make函数是 Go 语言中用于创建切片、映射（map）和通道（channel）的内置函数。通过make函数创建切片时，可以指定切片的长度和容量。
slice := make([]int, 3, 5) // 创建长度为3，容量为5的切片 fmt.Println(slice) // 输出 [0 0 0] 在这个例子中，切片slice的长度是3，容量是5，所有元素初始化为0。
1.3 使用切片字面量创建切片 可以像数组一样使用字面量创建切片。不同的是，切片不需要指定长度，长度由初始值的个数决定。
slice := []int{1, 2, 3, 4} fmt.Println(slice) // 输出 [1 2 3 4] 2. 切片的长度和容量 长度：切片中的元素个数，通过len()函数可以获取切片的长度。 容量：切片从起始位置到底层数组末尾的元素数，通过cap()函数可以获取切片的容量。 示例：查看切片的长度和容量 slice := []int{1, 2, 3, 4, 5} fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:55:56 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 011.Go基础 切片" href="https://ycchi0.github.io/posts/011.go%E5%9F%BA%E7%A1%80-%E5%88%87%E7%89%87/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">010.Go基础 数组
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，数组是一种固定长度、同构（同一类型）的数据集合。数组可以存储同一类型的数据元素，并且数组的长度在声明时就被确定，不能动态改变。Go 语言的数组有明确的类型和长度，因此与一些动态语言中的数组不同，Go 的数组在使用时需要考虑其长度和类型。
1. 数组的定义 在 Go 语言中，数组通过方括号[]定义，方括号中的数字表示数组的长度，之后跟随数组中元素的类型。数组的长度是数组类型的一部分，因此长度不同的数组是不同的类型。
示例：数组的定义和初始化 var arr [5]int // 声明一个长度为5的int类型数组，元素默认值为0 fmt.Println(arr) // 输出 [0 0 0 0 0] 在这个例子中，声明了一个int类型的数组arr，它有 5 个元素，每个元素的初始值为0（因为 Go 中的整数类型默认值是0）。
2. 数组的初始化 数组在声明的同时可以进行初始化。可以使用字面量的方式为数组赋值，或者只初始化部分元素，剩下的元素会使用该类型的零值进行填充。
示例：数组的初始化 arr1 := [5]int{1, 2, 3, 4, 5} // 初始化一个长度为5的数组 fmt.Println(arr1) // 输出 [1 2 3 4 5] arr2 := [5]int{1, 2} // 部分初始化，剩余元素自动赋值为0 fmt.Println(arr2) // 输出 [1 2 0 0 0] 可以通过这种方式只初始化数组的一部分，未初始化的元素会自动设为该类型的默认值。
3. 使用自动推断长度的数组 在数组初始化时，可以省略数组的长度，Go 会根据提供的初始值个数自动推断数组的长度。
示例：自动推断数组长度 arr := [....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:55:16 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 010.Go基础 数组" href="https://ycchi0.github.io/posts/010.go%E5%9F%BA%E7%A1%80-%E6%95%B0%E7%BB%84/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">009.Go基础 指针
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，指针是指向变量内存地址的变量。指针可以用来直接操作内存，并且可以通过指针共享数据，避免不必要的拷贝。在 Go 中，虽然没有像 C 语言那样的指针运算，但 Go 提供了简单且安全的指针功能，使开发者可以在安全的环境下进行内存操作。
1. 指针的基本概念 指针是保存内存地址的变量。通过指针，我们可以间接地访问或修改变量的值。
示例：指针的基本使用 var x int = 42 var p *int = &amp;x // 获取变量x的地址，并将其赋值给指针p fmt.Println(p) // 输出内存地址，例如：0xc0000140b0 fmt.Println(*p) // 输出指针p指向的值，即42 在这个例子中：
&amp;x 是取变量x的地址，返回一个指向x的指针。 *p 是解引用操作，通过指针p访问其指向的变量的值。 2. 指针类型 Go 语言中的每种类型都有其对应的指针类型。例如：
int类型的指针是*int float64类型的指针是*float64 自定义类型的指针也是类似的。 示例：不同类型的指针 var a int = 10 var b float64 = 25.5 var c string = &#34;hello&#34; var pA *int = &amp;a var pB *float64 = &amp;b var pC *string = &amp;c fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:54:55 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 009.Go基础 指针" href="https://ycchi0.github.io/posts/009.go%E5%9F%BA%E7%A1%80-%E6%8C%87%E9%92%88/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">008.Go基础 函数
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，函数是程序的基本构建块之一。函数定义了可复用的代码块，通过传递参数和返回值来实现逻辑封装。Go 语言的函数具有灵活和强大的特性，如支持多返回值、匿名函数、闭包以及延迟执行（defer）等。接下来，我将介绍 Go 语言中的函数特性及其使用方式。
1. 基本函数定义 Go 语言中，函数的定义使用关键字func，并且参数和返回值的类型必须显式声明。
func 函数名(参数列表) 返回值类型 { // 函数体 } 示例：基本函数 func add(x int, y int) int { return x &#43; y } func main() { result := add(3, 4) fmt.Println(result) // 输出 7 } 在这个示例中，add函数接受两个int类型的参数，并返回它们的和。
2. 多返回值函数 Go 语言允许函数返回多个值。这在需要返回结果和错误状态的情况下特别有用。
示例：多返回值 func swap(x, y string) (string, string) { return y, x } func main() { a, b := swap(&#34;hello&#34;, &#34;world&#34;) fmt.Println(a, b) // 输出 world hello } 在这个示例中，swap函数返回两个字符串，通过多重赋值操作接收返回值。...</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:54:38 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 008.Go基础 函数" href="https://ycchi0.github.io/posts/008.go%E5%9F%BA%E7%A1%80-%E5%87%BD%E6%95%B0/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">007.Go基础 Chan
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，chan（通道）是一种用于在多个 Goroutine 之间传递数据的机制。Go 语言通过 Goroutines 实现并发，而通道（Channel）是这些 Goroutines 之间进行通信的工具。通道可以发送和接收数据，帮助程序在并发场景下保持数据的一致性和同步性。
通道的定义与基本用法 通道在 Go 中是一个类型化的管道，声明时需要指定通道传输的数据类型。你可以创建一个传输不同类型数据的通道，比如传输整数、字符串或结构体。
1. 通道的声明和初始化 使用make函数来创建通道：
ch := make(chan int) // 创建一个传输int类型数据的通道 2. 发送和接收数据 发送数据到通道：使用&lt;-符号将数据发送到通道。 从通道接收数据：使用&lt;-符号从通道接收数据。 ch := make(chan int) // 向通道发送数据 go func() { ch &lt;- 42 }() // 从通道接收数据 value := &lt;-ch fmt.Println(value) // 输出 42 在上面的示例中，go func()是一个 Goroutine，运行在一个独立的线程中。它将42发送到通道ch中，主 Goroutine 则从通道中接收该值并打印。
通道的同步特性 通道不仅仅用于传递数据，它还可以作为一种同步机制。当一个 Goroutine 尝试向通道发送数据时，除非另一个 Goroutine 正在从该通道接收数据，否则它会被阻塞。同样，接收操作会阻塞，直到有数据从通道发送过来。因此，通道可以用来确保多个 Goroutine 之间的操作同步。
示例：同步两个 Goroutine ch := make(chan bool) go func() { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:54:16 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 007.Go基础 Chan" href="https://ycchi0.github.io/posts/007.go%E5%9F%BA%E7%A1%80-chan/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">006.Go基础 循环语句
    </h2>
  </header>
  <div class="entry-content">
    <p>在 Go 语言中，循环语句主要通过for关键字实现。Go 语言不像其他一些编程语言（如 C、Java）有while和do-while循环，for是唯一的循环结构，但它非常灵活，可以实现多种类型的循环。以下是 Go 语言中几种常见的循环用法：
1. 标准的for循环 这种for循环和 C 语言、Java 中的for循环类似，包含三个部分：初始化语句、条件表达式和后置语句。
for i := 0; i &lt; 10; i&#43;&#43; { fmt.Println(i) } 初始化语句：在循环开始时执行一次（i := 0）。 条件表达式：每次循环前都会判断，条件为true时继续执行循环（i &lt; 10）。 后置语句：每次循环结束后执行（i&#43;&#43;）。 2. 类似while的循环 如果省略初始化语句和后置语句，for循环可以用来模拟while循环：
i := 0 for i &lt; 10 { fmt.Println(i) i&#43;&#43; } 这种形式的for循环类似于其他语言中的while循环，在条件为true时持续执行。
3. 无限循环 如果for的条件表达式也被省略，那么就变成了一个无限循环：
for { fmt.Println(&#34;无限循环&#34;) } 这种循环通常与break或return配合使用，用于在特定条件下退出循环。
4. range 关键字遍历集合 Go 语言的for循环还可以结合range关键字用于遍历数组、切片、映射和字符串：
// 遍历数组 arr := []int{1, 2, 3, 4} for index, value := range arr { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:53:56 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 006.Go基础 循环语句" href="https://ycchi0.github.io/posts/006.go%E5%9F%BA%E7%A1%80-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">005.Go基础 分支语句
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言中的分支结构用于根据条件执行不同的代码路径。常见的分支结构有 if 语句、switch 语句和特殊的 select 语句。每种分支结构都有其适用场景，下面我将详细介绍它们。
1. if 语句 if 语句是最常用的条件分支结构，依据一个布尔表达式的结果来决定是否执行某段代码。Go 语言的 if 语句语法简单，且支持可选的初始化语句。
语法： if condition { // 当 condition 为 true 时执行 } 示例：基本 if 语句 package main import &#34;fmt&#34; func main() { x := 10 if x &gt; 5 { fmt.Println(&#34;x 大于 5&#34;) } } 示例：带初始化语句的 if Go 语言的 if 语句支持在条件判断前执行一个短语句，这个特性通常用于声明和初始化局部变量。
if x := 10; x &gt; 5 { fmt.Println(&#34;x 大于 5&#34;) } x 只在 if 语句的作用域内可见。 if-else 语句 if condition { // 当 condition 为 true 时执行 } else { // 当 condition 为 false 时执行 } 示例：if-else 语句 x := 3 if x &gt; 5 { fmt....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:53:27 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 005.Go基础 分支语句" href="https://ycchi0.github.io/posts/005.go%E5%9F%BA%E7%A1%80-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5/"></a>
</article>

<article class="post-entry"> 
  <header class="entry-header">
    <h2 class="entry-hint-parent">004.GO基础 运算符
    </h2>
  </header>
  <div class="entry-content">
    <p>Go 语言的运算符主要分为以下几大类：算术运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符。每类运算符都用于特定的操作，帮助程序完成各种计算和逻辑判断。下面是详细介绍：
1. 算术运算符（Arithmetic Operators） 算术运算符用于执行基本的数学运算。
运算符 描述 示例 结果 &#43; 加法 5 &#43; 3 8 - 减法 5 - 3 2 * 乘法 5 * 3 15 / 除法 5 / 2 2（整除） % 取余 5 % 2 1 &#43;&#43; 自增 a&#43;&#43; 等同于 a = a &#43; 1 -- 自减 a-- 等同于 a = a - 1 注意：
&#43;&#43; 和 -- 是 后缀运算符，即先返回当前值，再自增或自减。 整数除法会丢弃小数部分，例如 5 / 2 的结果为 2，而不是 2....</p>
  </div>
  <footer class="entry-footer"><span title='2024-10-16 12:52:59 +0000 UTC'>October 16, 2024</span></footer>
  <a class="entry-link" aria-label="post link to 004.GO基础 运算符" href="https://ycchi0.github.io/posts/004.go%E5%9F%BA%E7%A1%80-%E8%BF%90%E7%AE%97%E7%AC%A6/"></a>
</article>
<footer class="page-footer">
  <nav class="pagination">
    <a class="next" href="https://ycchi0.github.io/page/2/">Next&nbsp;&nbsp;»
    </a>
  </nav>
</footer>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://ycchi0.github.io/">Ycchi0 Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
